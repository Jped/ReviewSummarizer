{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871/ref=pd_rhf_dp_s_pd_crcd_0_2?_encoding=UTF8&pd_rd_i=0262510871&pd_rd_r=f23b48a0-5b97-473c-8cdd-805e0d59bf5c&pd_rd_w=VxKQA&pd_rd_wg=Ulq03&pf_rd_p=c6269878-d677-4a89-a68c-ff0df2b6ce6c&pf_rd_r=J0DZWERF1HJTT166H6D1&psc=1&refRID=J0DZWERF1HJTT166H6D1",
    "name": "Structure and Interpretation of Computer Programs - 2nd Edition (MIT Electrical Engineering and Computer Science)",
    "review-count": 187,
    "ratings": {
        "5 star": "69%",
        "4 star": "8%",
        "3 star": "5%",
        "2 star": "1%",
        "1 star": "17%"
    }
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=1",
    "reviews": [
        {
            "review_text": "This was the book that made me want to be a computer programmer. When I read it, I had no knowledge of programming beyond a little Pascal, and rudiments of C. It had a massive impact on me. It consumed me, to the point where I had difficulty finishing assignments for my classes (I did not study CS as an undergrad). What the book does is give you a vocabulary and knowledge about programming that is hard to find anywhere else. The text, the examples and exercises, have a mathematical flavor, and that may turn off many potential readers, who would rather gadget around than find elegant solutions for the 8-queens puzzle or efficient algorithms to compute Fibonacci numbers. I've lent this book to several friends who were interested in learning to program, and in all cases they have returned it to me, saying it went over their heads. There seem to be two camps in computer programming: - the gadgeteers, who want to hook devices together and make them do fun things - the scientists, who appreciate computing as a medium in itself This book is for the second type.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Structure and Interpretation of Computer Programs is one of those much admired, frequently discussed, oft purchased but rarely read classics. It's not an easy read: It took me four tries to get through it. But it's worth the effort: By the time you are done you will know about imperative programming, functional programming, meta programming, lazy data structures and everything in between. This is one book that should be on every programmer's list.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I have only worked part of the way through the book, but it is one of the best books I've had the pleasure of learning from. It has an academic mathematical flavor to it, and the material is fairly dense; but the authors are masterful teachers and the exercises are very effective. Scheme is a fascinating language. At first it is uncomfortable to look at, especially if you're used to more mainstream languages. But once you get acclimated, you begin to see the beauty and raw power it holds. I recommend using the Racket IDE with the SICP extension when working through the book.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "You need it, too. I won't pretend to have more useful insight into the art and craft of programming, or into SICP's relationship to it, than Paul Graham or Peter Norvig- if you want to know which reviews to trust, look these cats up. The discussion in the reviews usually concludes that this is the book that separates the computer scientists from the mere programmers. There is a definite logic to this. If you want a book that will have you churning out code that does something helpful in half an hour(because you don't think the several ways to calculate the Fibonacci Sequence are helpful), by all means, pick up Learning Perl or just read the Python documentation. They are great tools. If, however, you want to tool up on problem-solving technique a whole level or three higher up, SICP is for you. The Wizard Book is about learning to think better. Here is where I diverge from the idea that this book is for only computer scientists, though. I am an artist, graduated from college with a BA in art, going to graduate school for an MFA. SICP is one of the books that changed how I work and think. It will make you a better programmer if you read (and reread (and reread)) it in the same way that learning Latin will make you understand language itself in a whole new way. I use ideas from SICP constantly, to design software, but also to design staircases. The book is slow-going, no doubt about it, but you'll have a whole new mental toolset at the end. One caveat- this book is freely distributed in its entirety on MIT's website. I still bought a copy, though: who knows how long this internet thing will last, but SICP is going to be relevant forever.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Great book. Has changed my perspective on the subject. I would classify it as an advanced book in the subject of computer programming. If you have a solid understanding of the fundamentals of computer science I recommend reading this book.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "One of my favorite textbooks from undergrad. It was used in my first CS class. It was first exposure to a language other than BASIC, so I acknowledge the bar was pretty low, but I was blown away.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "The authors have an ambitious goal - to fundamentally change the way you think about computing. Scheme is used as a vehicle to illustrate how large, complex systems can be designed by abstraction. Several real-world examples are used: a picture language, a circuit simulator, a compiler and a PROLOG-like pattern matching language. To get a flavor of this book, search for \"SICP Lecture 1a\" in Google Video. It's the first of 20 lectures delivered by the authors of the book in 1986. If you decide to purchase the book, use it in conjunction with these lectures to get the complete SICP experience. You will come out of a smarter, wiser software engineer. Also, how often do you see visionary computer scientists like Peter Norvig and Paul Graham give 5 stars to a book?",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I've worked through the first three chapters of exercises, and they are challenging and fun. I'm learning scheme so that I can get better at functional programming in general, mostly in Clojure and Javascript. Scheme is a perfect \"teaching language\", though, and I think that this book should be any aspiring programmer's first introduction to programming before they even touch a compiled language.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This text introduces CS essentials in an engaging and practical way. The first two chapters on procedural and data abstraction are much better CS preparation than learning Java or C++ or Ada or Pascal. Abstraction and specification in software development are absolutely necessary if software \"art\" is ever to become a \"science.\" I used this text last year to teach a one year introduction to computer science to some rather advanced homeschooled high school students. Scheme is a much better choice for a teaching language than C++ or Java. There is no need to deal with memory management issues as with C++ and the development model is simpler than with Java. And scheme makes many things easier to achieve than with other languages: higher-order procedures (chapter 1) and hierarchical data (chapter 2). For my own enjoyment and personal enrichment I have used chapters 4 and 5 as a basis for my own explicit control evaluator for scheme in C++. A classic. Every CS graduate should do remedial work now and read this text, if they have not done so already.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This is hands down the most personally influential book I've ever read on computer science. It's on \"computer science,\" so the going can get pretty heady sometimes. It's also deep. Unless you're exceptionally gifted, you won't grasp all the material the first time around. I'm on my third run through of some parts, and still feel like I've barely scratched the surface. On a side note, chapters 1-3 should be required reading for all programmers. Four and five, while much more interesting (imho,) will be much less useful in your day to day software engineering tasks.",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=2",
    "reviews": [
        {
            "review_text": "This book is not for the average person with a casual interest in computer programming, or for someone who wants to learn Scheme and Scheme only. This book is designed for motivated study, as you would find in a very difficult college course. It will make you better at thinking about problems. You will become a better programmer by reading it (and completing the exercises), but only if you are willing to put serious effort into understanding it.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I bought this book at the recommendation of a speaker on Functional Programming at a Computing Conference. It was on his list of the 10 most important books in Computer Programming. I am doing the \"paradigm\" shift to Functional Programming and Learning Clojure, so I thought it would be a good book to have on my Shelf. And the Paperback version was less expensive than the hardback. It arrived very quickly in excellent shape. I've been developing software since the 70's and have undergone the shifts in COBOL to Yourdon's Structured Design, to C then C++, OOP in Java and C++ and now to Clojure and Scala. I'm using this book as a supplement to learning Clojure, although the code is in Lisp. The material is very dense and thorough. The beauty of this book, however, is it leads you into Functional Programming without one even knowing it. I am only part way through it (converting the examples from Lisp to Clojure as I go) and my understanding of FP has grown by leaps and bounds.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "As others have gone into, this is a great programming book for many reasons, and is a must-read for anyone who is interested in software design. Rather than waste time reaffirming the excellent positive reviews of this book, I wanted to cover something that I have not seen in the reviews: namely that there are multiple publishers for this book (as it is an \"open source\" book). At the time of writing, there is this McGraw-Hill publication, and, for 40% less, an MIT press edition. While I have not seen the McGraw-Hill version in person to see what quality benefits it has over the MIT press edition, I am very happy with the binding and print quality of the MIT press edition and would advise saving your money unless you have a particular reason you want to spend a lot more money for the same content.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I will explain the bad and then the good things about this book. There are a couple of bad things, but chief among them the ridiculous assumptions the author makes about the reader. If you do not have a solid mathematical background DO NOT GET THIS BOOK. You will be hopelessly confused at multiple points. The authors do not explain any mathematical reasoning save a few examples. That is my main complaint, but I did have a thorough mathematical background before using this book. One other thing is that the book doesn't go through algorithmic complexity, which is a fairly important concept. This book does explain many computer science techniques fairly well. Out of the parts I have read the only topic lacking is message passing. I found the section to be quite short. If you can read a section and reflect it will allow you to grasp the implications of the material in front of you. WARNING: You do need critical thinking skills and the ability to analyze what you are reading. One other thing is that some of the problems given throughout the book can be REALLY difficult. If you get stuck don't be afraid to ask for help or look up an explanation online. Other than that I will be holding on to this book for years to come. I did enjoy going through it.",
            "review_rating": "4.0 "
        },
        {
            "review_text": "Working through this book reminded me of a couple of lines from \"Zen and the Art of Motorcycle Maintenance\": \"How do you paint the perfect picture? Make yourself perfect, then paint naturally.\" How do you write perfect code? Make yourself perfect, then write code naturally. This book is a great way to perfect yourself for coding. If you find the approach a little too dry and academic, then try \"The Little Lisper\" or \"A Little Java, A Few Patterns.\" These don't cover the same range of subjects, but they get you thinking in a good way about how to develop solutions.",
            "review_rating": "4.0 "
        },
        {
            "review_text": "Great book covering LISP, lambda calculus, and the meta-circular interpreter.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I wish I would have read this book 10 years back... This is a classic. Must read for every computer scientist.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This is a fantastic book. I agree with the reviewers that say this book as little to do with contemporary software design and practice, and that's a shame, because if this book HAD more influence on contemporary software design, programs would work much, much better. This is a book about writing software, controlling complexity, identifying abstractions. It is filled with intelligence and wisdom. It is also a lot of fun.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book was a series of lecture notes and handouts when I attended school. I purchased a bound copy long after I'd take the course, to introduce my children to this way of thinking. Abstraction, Lisp, and the Object-oriented style of programming are all introduced. The problem sets go into useful application areas, and the writing style is straightforward. You may have to search a bit to find a vintage Scheme compatible with the exercises used in the book - people on the Internet (particularly the scheme community) are very helpful here. Good luck! This will change how you think about software, and in a mind-expanding way.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Inductive reasoning aims at simplifying functions just enough to make them general. Simple does NOT equal easy! When Functional Programming (and its predecessors-- combinatory logic (1925) and lambda calculus (1930)) were first invented, they were aimed at clarifying mathematical logic. This \"holding variables constant\" or binding or eliminating them for \"pure\" (mathematical) functions, has been extended to Functional Programming, initially to better understand what programming is in general, then to evaluate mathematical functions while avoiding some of the complicating factors (side effects) of imperative/procedural programming. Because of this, when you think of a function in imperative, you immediately think of variables, and such functions can very easily morph both at the algo/function f(x)-> g(x) level, and at the x (variable level) itself (data changing as you execute). In functional programming (the subject of this text), a function is, well, a MATH function! So, evolving from math, and consisting OF math, it would be a little surprising to criticize the fact that this IS A MATH BOOK. (Sorry, it is). On the other hand, holding those variables constant and looking directly at functional mappings (particularly recursion) can \"AHA\" us into seeing how computers and programming \"really\" work without the complications of heavy imperative morphs. After C# 3 and in some Perl, these tried and true oops also have some functional classes now, so we are moving toward a more hybrid world, making this book FAR from out of date, even though it is \"temporally\" older. As well, some of your favorite math, research and engineering programs (Maple, Mathematica and R, for example) have numerous functional features. The old FP standbys are, of course, Lisp, Scheme, Hope, Haskell, Clojure, Racket, Hope, Scala, F#, etc. which you probably think of more as \"math\" programs. But, hopefully not a surprise, SQL itself strives at far less mutable value structures than imperative, and thus tilts toward functional also. FP, to be very honest, WAS designed to teach and understand programming (at compile/interpret levels, not necessarily algorithms, computational complexity or even advanced data structures), not originally create useful programs! \"R\" and many others have proved that to be aiming low, and the newer FP books do of course get deeply into more recent data structures. Thus, the reason for so many negative reviews! This is NOT your usual \"how to program\" or even \"what are programs\" text-- it really is about linking mathematics and computer science at both high and deep levels. So, if you aren't really up on math (from basics like sets and real number mappings all the way up to Lie Algebras and tensors), you might get lost with this rare gem of a book. On the other hand, the pain of working through it will give you a perspective on computer science that will forever change your point of view. Even if you code all day like I do, you'll LOVE taking this journey both to the 30,000 foot level, as well as down to the real action between compiling and interpreting-- via the MATHEMATICS of \"pure\" functions, minus the confusion of changing states, variables and data we play with every day in the imperative version of functions. Don't believe that this \"simplification\" makes things easier to get-- unless you know functions from a deep math view, this will be a tough climb. But... worth it if you're willing to do the work! Most other books on \"discrete math\" are really UI catch ups for all the computer/math that's now been removed from High School curricula, making this one of the few \"real deals\" that are at a bright, high undergrad level, NOT catch up. By removing calculus from HS requirements, we're teaching 2,500 year old math, and adding the basics brings us up to 1666 or so. This book rapidly catapults our function math vs. function computing into the new century! Highly recommended IF you're not turned off by advanced math functions, mappings, properties, etc. The next time someone asks how a special or CAS function can run faster interpreted than compiled, you'll have a MUCH different answer! And of course the heart of all dynamical systems today includes differential equations, which are essentially recursive function processing. BEFORE AND AFTER: If you're not \"quite\" ready for this level of FP and Lisp, you can get a great, inexpensive backgrounder with Dover's An Introduction to Functional Programming Through Lambda Calculus (Dover Books on Mathematics) . Mathwise, many Dover books on the keyword recursive functions will help. For a freebie intro, Graham's famous \"on lisp\" is now available as a free download, and is a bit above the level of this book. For the \"greatest intellectual programming book ever written\" (far beyond the level of this book, covering advanced Lisp macros, closures, etc.), check out (AFTER reading this): Let Over Lambda . Only 1% of programmers really understand Common Lisp, and only 1% of those would tackle the unhygenic macros in Let Over-- yet it is so intellectualy challenging that coders and engineers at all levels are astonished when they read it. Shows how high the bar can really get! (Lisp tends to do that, right?). IS IT DATED? In answer to a bunch of emailers asking that, NO-- the principles of functional are still the same, even if Common Lisp and Scheme have been updated. In fact, today, combinations of functional, imperative and logical are happening more and more (called mixed paradigm programming). However, if you want a GREAT, VERY RECENT book as both a warm up and an update to Abelson, try this little beauty by the same author as the Little Schemer: Realm of Racket: Learn to Program, One Game at a Time! . It will fill in where Abelson is a little out of date AND prepare you for his depth. WARNING: PLEASE BE SURE to get the 2nd Edition of Abelson, he updated it significantly for the relationship between time and memory, a relationship that is even today undergoing a LOT of research in many fields.",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=3",
    "reviews": [
        {
            "review_text": "First of all, this book is quite good. That being said, the book suffers from a few flaws that make is less than easy-going for probably the majority of readers. To start with, I'll mention that the choice of typesetting used in this book makes it a bit cluttered on the eyes. Although I readily admit things like this *shouldn't* matter, they invariably do. This really is the responsibility of the publisher and not the author but the end product is a book that can be a bit numbing to read for long periods (at least in my opinion). Second and more seriously, the book is not a \"stand-alone\" item. For instance, to implement the \"Picture Language\" examples, one would need add-ons to the standard MIT-Scheme package that the authors refer to. In the problems on Data-Directed Programming focusing on association tables, the reader really is at a disadvantage in not having an implementation of the tables incorporated in the standard-issue MIT-scheme. They are constructed in Chapter 3 and this kind of \"wait-and-see\" makes the problems, in my opinion, harder than they really need to be. Also, the Object-Oriented Programming avoids (for understandable reasons) many of the technical features that highlight its robustness. It's not an ideal book for OOP. SICP gives the reader (or I should say, it gave THIS reader) the impression that this is also not a book for people learning programming, it is a book for people comfortable enough with programming to deal with a lot of these issues quickly. If used in a class setting this is probably easily overcome in labs. On to the strengths. The problems in the book range from fairly trivial to quite difficult. One of the strengths of the book is that they introduce a lot of topics and do not shy away from interesting and challenging exercises. The bar is set probably quite high for the undergrads learning this material but for self-study some of the problems can be somewhat daunting. Another strength, in my opinion, is what some reviewers cite as a weakness; the use of Scheme. Aside from the implementation issues above, Scheme is really well-suited (having few primitive control structures) to isolating the concepts of programming (in contradistinction to the emphasis on syntax that plagues most introductory books). The argument that Scheme is \"useless\" depends highly on your definition of \"use\", since solid understanding of program organization is a valuable language-free skill. Overall, as I mentioned, the book is quite good. Just don't expect that because it is touted as an introductory text that it will be an easy read. There is something in it for everyone.",
            "review_rating": "4.0 "
        },
        {
            "review_text": "I first used this book in conjunction with an MIT video course I took back in 1987, after almost 10 years of professional programming. It truly opened my eyes to a larger world. Now I recommend it to anyone who is serious about achieving technical elegance, no matter what the platform or environment. So go out and buy the damn book!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "The content is phenomenal. But shame on you MIT Press for the actual printing of this book. There are numerous reviews here that discuss the merits of this book. Rather than repeat what's already been said numerous times, I'm going to tell you something new that you should know before purchasing this (expensive) book. For $50, MIT Press could have done MUCH better. 1. The paper is cheap. Highlighting will show through on the opposite side. Terribly annoying. 2. The binding is cheap. For a book of this caliber and price point, it should have a \"lay flat\" binding. 3. The covers are cheap. I've only been reading the book for 1 week, and the clear plastic coating is already peeling up from the edges of both front and back covers. This is easily a 5-star book with regards with its content. Unfortunately, MIT Press gets 3 for making extremely poor printing decisions. Maybe greedy is a better description. Books of this caliber should last a lifetime. This one won't come close. Regards ~ Jason Perry (purchased by Geri Perry)",
            "review_rating": "3.0 "
        },
        {
            "review_text": "Having first watched the authors' excellent video lectures that were built upon the first edition of this textbook I naturally had very high expectations when I set my hands on the second edition. The breadth of the material covered by this book is very much in line with its title. The central topic of the book, as one would expect, are computer programs. And it is here that the book really shines, progressively refining the readers' idea of what a computer program essentially is through multiple interpretations and re-interpretations of that idea. That being said, this book does take the unconventional approach: it uses a relatively unknown language called Scheme and goes into considerable effort to promote functional programming, an approach still considered pariah in the industry. But this is no flaw in my opinion. Current trends in programming language evolution indicate that many ideas that were hitherto the sole province of functional programming will become more and more present in mainstream languages. The beauty of Scheme is that it hardly has any syntax and its few special forms can all be learned in a very short time, liberating the reader from the so ubiquitous tyranny of syntax that plagues the majority of programming textbooks out there. The Scheme that the authors present in this book has no looping constructs: believe you me, there really is something special in writing loops via function recursion - it reminded me of my high-school days and the infamous goto's I would regularly get chided for by the teacher. Interestingly, in the fourth chapter of the book you get to implement some of these absent looping constructs yourself. Another nice thing about the book is that it constantly keeps challenging you: the exercises get progressively more difficult and there are very few one could skip on the basis of them being trivial or non-engaging. I was surprised though, to have seen that many colleges did, or still do, use this textbook as a basis for a first course in computer programming. I find this inappropriate because there is far too little in the way of teaching the essential algorithms and program design patterns for beginners to really profit from here. In my opinion, the material in this book is more suited for computer science sophomores instead. One of my biggest gripes with this text had to do with the way the exercises were laid out: on far too many occasions, the book doesn't present you with enough of workable code to test and verify your solutions - while an experienced programmer will have easily dealt with this issue by consulting MIT's 6.001 course webpage and downloading the code set for the book, a soloing beginner could possibly be frustrated to the point of giving up on the book. The stream section in chapter 3 is especially troublesome since there is no officially provided workable code at all either in or outside the text - again, the solution is pretty simple, but to a beginner probably insurmountable without assistance. I strongly suggest using the DrScheme environment and switching to Lazy Scheme for the purposes of this section. In fact, one can use DrScheme for most of the book, as it's far more user friendly than MIT Scheme Emacs and diverges from MIT GNU dialect of Scheme in only a few sections of the book. One annoying feature of DrScheme is that it has recently rendered set-car! and set-cdr! procedures obsolete: fortunately, the solution is simple. Just add \"(require r5rs)\" at the top of the definition window. A second potential problem for students that I see, is a thorough lack of commentary on domains and codomains of functions in the programs. Since Scheme is a dynamically typed language, there is no self-documentation present as there would be were the programs written in a typical statically typed language such as C++, and for a streamlined reading experience such documentation is a must. With all of this in mind, and considering this textbook as an intermediate rather than beginner level material, I rate it as very good, with potential for excellence should the problems I mentioned be resolved. If you decide to read the book, I warmly recommend that you watch the eponymous video lectures in parallel as they are thoroughly entertaining and on some occasions go into interesting theoretical discussions not to be found in the book (you definitely don't want to miss the lecture on the metacircular evaluator as it's far more clear than the presentation in the book and concludes with some really nice lambda calculus hacks).",
            "review_rating": "4.0 "
        },
        {
            "review_text": "This book is great for people that want to learn the key ideas in Computer Science. I've never seen a book covering so much topics and explaining them in such a easy-to-understand way. It talks about Functional Porgramming, OOP, Data-directed Programming, Concurrent Programming, Stream-Oriented Programming. Especially the OOP part. I think it helps me to understand the Object Model behind a lot of other OO language. And in chapter 4, it guides reader to write a real Scheme interpreter. By reading through this chapter, I understand the internal mechanism of the interpreter, and several different interpreter models, including lazy evaluation, indeterminism programming and logic programming. I've learned a lot from it.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Not only is this, by far, the best book on programming I've ever encountered (sorry Dr. Knuth,) but it stands alone as a profound treatise on the nature of programming and knowledge itself. All of the best programming books of the last 30 years borrow extensively from SICP, but this boom remains a essential read for programmers of all levels. If Descartes wrote Scheme, I suspect it would bear profound resemblance to this work.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I used this book to teach myself Scheme. It used to be offered at MIT as 6.001 but unfortunately they removed it in favor of 6.01 Python. Scheme is very much the \"Latin\" of programming languages: it's not extremely useful but it teaches you how to approach programming and how to think about it. Highly encouraged.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I wouldn't recommend it to someone with no prior computer science skills unless they are looking to become a computer scientist. But, for those looking to do CS for real, this book along with the free classes at MIT OCW are honestly a must.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I purchased this texbook for my first computer class since it was required. It's a great book, but I'm glad we did not cover it entirely. Too much material, and Scheme is not that popular of a language. Price was right though!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Gotta read it.",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=4",
    "reviews": [
        {
            "review_text": "good for theoretical stuff but I would recommend the \"Learn python/c/regex the Hard Way\" series for beginners first. Skill is more useful than theory (except when it isn't). However this is a very readable book, and it really helps when watching the 80s Youtube lectures by the author, and with understanding how engineers think in general. There's a reason MIT posted his lectures online early, and why they recorded them in the first place.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "great",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Although used as an introductory text at MIT, this book is definitely not for the average new programmer. From the very beginning, there's a big focus on recursion and recursion can be a tricky topic even for experienced coders. But what makes the book EXTRA difficult for anyone is the complete lack of comments in the code examples. A college freshman writing uncommented code should get an F. Also the procedure and variable names that are not as clear as they should be. From its reputation I expected some kind of inspiring book on the zen of software theory, but instead it was a bit of a slog. It was written as a textbook after all. Realize that there are no answers for most of the exercises. You won't get the full value out of the book unless you buy the companion instructor's manual.",
            "review_rating": "3.0 "
        },
        {
            "review_text": "This text has already proved valuable to me as a supplement to a course on Functional Programming in Scala (on Coursera).",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I bought this book because it is one of the pinnacles of computer science/engineering literature. It is a great read, perfect for introducing functional languages to newbies and professionals alike. Highly recommended.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I have no words to express my gratitude towards authors of this book. It is really helping me to thorough (and learn new) concepts I have studied during college days. I would recommend this book to software developers who has 3 or more years of experience. I am still reading this book, finished almost 2 chapters, its helping me to tackle the problems in a better way. I love this book..",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Originally rented this book for a semester-long class on Programming Languages. Ended up buying it because it is just that good. This was my first introduction to functional programming and Scheme (Lisp) and it has really helped me to grow as a programmer over all. The book is chock full of useful examples and code that you can run and manipulate yourself, which makes for a great learning experience.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book trains your mind to do meta-circular interpreters and higher order functions, recursion, and other things schemers take for granted. hey you with thoes 1 * reviews your just a bunch of blubbers",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Awesome Book. As an aspiring functional programmer and lover of Lisp and Clojure, this book really drove home the benefits of Lisp dialects as well as other core programming concepts. Although the text was very academic, the conceptual applications for practical programming are amazing.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book is right up there just above LoL and Lisp In Small Pieces. If you are serious about Lisp (any dialect) this book is (one of?) the best. In fact, if you are serious about programming (an any language) then this book is a must read.",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=5",
    "reviews": [
        {
            "review_text": "Excellent and clear book. It stands the pass of time. The lectures for this class available from MIT are also inspiring, very interesting to watch despite the technology used on the day.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This is an honest to god tome of wizardry. Join the cult.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This is a book written by MIT computer-science professors for MIT computer-science students. It is therefore clearly not for everyone. But if you are the kind of person it is for, you will love it. I did.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book will not teach you how to write software. Don't read it if you don't already program, and program a lot. If you are looking for a delicious re-invention of the basics, that will leave you refreshed, and reminded of options you had forgotten.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Clear, as concise as the subject allows and well organized.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Nice.",
            "review_rating": "4.0 "
        },
        {
            "review_text": "The fast moving world of technology deems many books irrelevant but this work stands the tests of time.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Gets deep quickly!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Very interesting for starting in programming",
            "review_rating": "5.0 "
        },
        {
            "review_text": "A book to make software development professionals",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=6",
    "reviews": [
        {
            "review_text": "Reading this book will save the environment. You'll learn how to write efficient software that doesn't require the output of 3 coal burning power plants operating at 100% just to run. Reading this book can cure cancer. Want to know the real reason we haven't cured cancer? It's because too many companies need the yearly GDP of a third world nation for hardware purchases to run software,or to fix software written by men and women who didn't read this book. Reading this book will make the software you write more logical, less expensive to fix, less expensive to maintain, and less expensive to operate. Don't create new problems that prevents us from curing cancer, read this book. Reading this book cures alcoholism and improves health. Reading this book saves lives. Poorly written software is one of the leading causes of hypertension and other stress related health problems, including deaths attributed to heart attacks. At the very least, reading this book may save several people from crawling into a bottle to escape the mental abuse of understanding what your code is doing. Remember friends don't let friends write software if they haven't read this book. The life and sanity you save may very well be your own.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "An amazing book for anyone looking to do anything serious in the computer field.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Great book. Not only great, but awesome. Anyway",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Excellent state and quality of paperback.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "good",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Great supplier! This is an excellent text!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Just because the author graduated from MIT doesn't mean it's great. Like most academic books, this book relishes on sophistication and pedantics for the sake of academics. While it is true that there are some important concepts here, the concepts themselves are a bit self-explanatory. For example, he talks about modularity and how important it is to break code down to parts. Everyone learns that in introductory CS. I even learned that by experience before I took a computer course. I would've excused the dry writing if he had presented some timeless and interesting concepts. But there aren't any. I read a very dry book on algorithms, \"Algorithms in C\", and I really found it very useful because it presented some interesting concepts and had some minimal source code examples to follow. So I would not recommend this book at all. I didn't really get anything out of it.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "Just as expected",
            "review_rating": "4.0 "
        },
        {
            "review_text": "\"Ever-newer waters flow on those who step into the same rivers.\" Heraclitus *Structure and Interpretation of Computer Programs* \u2013 the second edition of which was published in 1996 \u2013 was used for many years as the text in the introductory computer science class at MIT and some other elite universities. Since the book develops its topics using the Lisp dialect Scheme, a \"functional\" programming language somewhat distant from the long-dominant imperative paradigm, among the larger programming community it has maintained a flavor of an esoteric, almost mystical approach to CS. It also recommends itself as a book long available legitimately in an electronic format in its entirety *gratis*. However, like the institutions (including MIT) that no longer use it as a main text I have to caution the autodidact about too strong a faith in its tenets. IT is continually moving and the knowledge of even ten years ago, let alone twenty, must be contextualized in terms of the bits that need to be shifted today. For someone like me who knew mathematical logic before he knew how to code, there is something delightful about the sweep of Abelson, Sussman, and Sussman's \"top-down\" coverage of computer science, beginning with the most basic steps in programming and ending with a model of a full-fledged compiler for Scheme (covering a bit of Algorithms and quite a bit of basic programming language theory along the way). However, I think the \"SICP\" doubter does not need to throw in the towel and the fanatic ought not to too quickly claim victory: since this is a book largely composed before the commercial Internet even existed, a sense of how to sell yourself as a \"full-stack developer\" will *not* be conveyed by singing along at home. Functional programming is a commercial reality (although, in one of the authors' unlovely verbal tics, the only reference to a functional language other than Lisp /Scheme is to a hypothetical 'lazy-evaluation' language called \"Hassle\") but the \"Lisp ethos\" is not even alive in the burgeoning AI world and the code you need to write will only correspond in the most general terms to what is presented here. Since the \"opportunity cost\" for looking at this is zero, *very much* not a reality for \"new classic\" CS books, and there is a great deal of fundamental CS which is introduced in an idiosyncratic way I will not say you ought not to look at this \u2013 *of course* you should. There are a few areas where the book still excels: the shift in Chapters 2 and 3 from functional programming's \"referential transparency\" to computations with state offers an opportunity to explain the role of \"environments\" in handling mutable data (far from obvious if you begin with imperative programming languages) and Chapter 5's exploration of assembler from Scheme's lambda-calculus perspective is genuinely illuminating. Still, even the principals would tell you it is the end of 2017 and not 1997, so keep your eyes open to what is really going on in CS today.",
            "review_rating": "3.0 "
        },
        {
            "review_text": "good deal",
            "review_rating": "4.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=7",
    "reviews": [
        {
            "review_text": "love",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Wanted to have a hardcopy, since this is a classic. NOTE: This book is available in PDF online for free.",
            "review_rating": "3.0 "
        },
        {
            "review_text": "I purchased this for my son. He indicates he thinks the book will be very helpful where he works as a programmer.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This is obviously a controversial book, given the split between 1 and 5 star reviews. Perhaps worth noting: I know a lot of students in computer science who hate it (but only about 50%) while I know no professionals, professors, or researchers who feel that way. In my (limited?) experience liking this book correlates strongly with skill and success in computer science thinking and research. It is not for people who just want to make the next killer app, though mastering the material might help with that. Although I am told it actually was used for beginners in a course at MIT, I do admit that I find that very hard to believe. I read this book after 2 decades of experience in programming and applied mathematics, and it was mind blowing to me. It really is a wonderful book, but one meant for people who have some experience--maybe for graduate students. (I know that I would make it required reading for any grad students I have doing computer science!) This book is really great for people like me who have been using computers for a long time (37 years for me), can program in a few languages (I've known and used more than 2 dozen), and who have picked up a lot of their ideas about computer science piecemeal. What this book did for me was place vast amounts of knowledge into a more meaningful structure. That was value beyond words. This book also reflects the past of computer science books. There was a time that these books focused on ideas and concepts and not so much on spelling out the explicit details of programming that today's students think that they require. (They don't actually, and unfortunately they are paying a price that they cannot even see for being spoon fed their programming knowledge.) This book is from a past when the important part was the ideas and understanding of why we program the way we do, not just learning the syntax of a specific language. That is what language manuals are for! (Wait...manuals. What are those?) Also troubling for students today is the use of LISP, a language that has been described as \"syntax free.\" It is about as close to syntax free as it is possible to get. Students might want to consider that most of the \"advances\" in computer languages in the last 25 years has been re-introducing deep features of LISP into other, weaker, post-LISP languages like the C/JAVA family, etc. I like the style, but I can see that some people might not like it. It is a clear statement of a distinct style of thinking in engineering. I think it is clear, and most of my colleagues who have read it agree. Perhaps the people who complain lack the technical vocabulary? I would tell people to keep going but to look up missing knowledge/vocabulary in Wikipedia. The book is worth the effort. A good read for people with a lot of disorganized knowledge who want help putting things into meaningful structures!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I'm a novice programmer, so when they introduced variable assignment a couple hundred pages into things I was particularly flabbergasted. How ugly it was, too! But then I realized that LISP is a functional language and if you really need to do much with that you probably shouldn't be using LISP.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book is the best academic book I've ever read! It is the most instructive book I've had. I studied Electrical Engineering, but thanks to the highly instructive style of the book I could easily follow the pages. It opened my eyes since the beginning, I didn't know anything about functional programming, iterative vs recursive, processes and their shapes, functional abstraction, first class functions, data abstraction and data structures, objects, imperative programming with its pros and cons, and so on.... Although I have not finished the book yet, in fact I am finishing chapter 3 (learning about Streams, which are delayed lists), I recommend it eyes closed. It's kinda fun because now I try to find a SCIP style of book for every other subject I'm interested, it became my standard.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "It's a great book, amazingly interesting read. It got delivered to me two weeks before I even expected it. I am still reading it.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I recently started reading the online version of this book (https://mitpress.mit.edu/sicp/full-text/book/book.html). I was not expecting anything in particular, but just a first few pages and I was hooked. I have several years of experience building high performance and highly reliable systems and at a certain point in your career, you crave simplicity. This is the simplest book on computer programming I have ever read. By simplest I do not mean easiest, on the contrary, you have to reread multiple times to get the gist of what the authors are trying to communicate. However, they do it in such a simple and convincing manner that a child could understand. I wish I had this book 20 years ago.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "ok",
            "review_rating": "3.0 "
        },
        {
            "review_text": "A must read!",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=8",
    "reviews": [
        {
            "review_text": "My first encounter with SICP was in the second year of university, where I took a course named \"SICP 1'. I already had working programming experience by that time, so the course wasn't hard, but I was struck by the beauty of the subjects it taught, by the Scheme language it used and by the long and interesting homework assignments it had. This course woke my curiosity about functional programming, and the Lisp family of languages in particular. A few years later, with much more experience behind my back, I've decided to tackle SICP seriously and read the whole book, solving the vast majority of the exercises. This endeavor took about 10 months, and I enjoyed it immensely. I think SICP is a wonderful book, a seminal work in the field of programming. It is one of those rare books every programmer should read. In this review I'll try to explain why. In contrast with most introductory books about programming that just teach you a language, SICP takes a far better approach. The main goal of the authors is not to teach Scheme, it is to teach programming. From the beginning, the book takes an integrative path, where the basic axioms of programming are presented, and later are fortified with examples and exercises. SICP teaches about computational processes - iterative and recursive. How to use them best in each situation, and how to implement them. It also explains abstraction by functional composition. These are topics rarely presented in programming books, but SICP puts them rightly in the first chapter, because they are the real stuff programming is based on. The example programs developed in the book are real, large, and exciting. You'll get to develop a powerful picture language, a generic object-oriented arithmetic package including complex and polynomial arithmetic, a simulator for digital circuits, a symbolic differentiation package, an interpreter for Scheme written in Scheme, an interpreter for a logic programming language similar to Prolog, a virtual machine for a simplified pseudo-assembly DSL, an interpreter for Scheme written in this pseudo-assembly, and finally a compiler from Scheme to the assembly language. All these examples are real, well-thought out exercises for skill, taken from beginning to a very complete end. In no other book such a wealth of topics is addressed in an accessible manner. A word about exercises in SICP. They are numerous, some of them are hard, but the exercises are the best way to really understand what the book tries to teach. In a manner, they're as integral part of the book as the text itself. The exercises are very well prepared and lead the reader through the examples coded by the authors into greater understanding of the topics taught. At times, it feels like the exercises are specifically designed to force you to think about the essence of the topics, and not just grasp them superficially. SICP commonly suffers from the criticism that it's too hard for beginners. Maybe this criticism is rightful, and universities should give a simpler introductory course to programming before SICP. But this is an aspect of the educational systems, not pertaining to the book itself. I wouldn't know, I never read SICP as a beginner. However it is being taught, SICP is an amazing book. It is by far the best programming book I have ever laid by hands on, and I seriously doubt that it will be surpassed any time soon. Reading SICP will enlighten you as a programmer, and make you a better one. I can't imagine one programmer who won't gain something important by reading SICP.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "If you are looking for the easy way out, you have the wrong book. SICP goes deep into the material and you have to go even deeper to understand it and come out as the better programmer. Reading this book in one sitting only works for the patient and intelligent. I consider myself to be both and I still had to work through it. I am a sophmore at MIT and when I took the course I had never programmed before, but after reading SICP and taking the course along with it, I believe I have come out to be the better person and programmer. The course is 4 months long, and I still found it difficult and falling short on time. The course is one of the hardest courses at MIT and probably the world and the book is equally difficult. Time with the material took me about 25+ hours per week on class time, reading and problem sets. I have never looked for the easy way out and neither does MIT and neither should the serious programmer. Reading this book has made me the better programmer and helped me understand programming in general as a whole. It has made my transition into more mainstream languages a whole lot easier. That is probably the only easy part about this book. I advise you to go online and try the problem sets along with reading this book and you will find that this is no frolic in the park, but definitely beneficial and even indispensible. If you are not serious and willing to work, then don't buy this book and stick with your \"Learn Pseudo-Programming in 21 days\". But if you are serious, buy the book and read it religously. It is no easier than reading the Bible itself, but it is as informative to Programmers, as the Bible is to \"the believer\". It is the \"Messiah of programming\" and you will benefit from it no matter what language you \"speak\",(program in).",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I have read a lot of reviews here which lament the use of Scheme for teaching the fundamental concepts in this book. People have stated that while the book pretends to be language-independent it relies solely on Scheme, which invalidates the point. I disagree strongly! I think part of the problem is that it takes a bit of time to really \"grok\" Scheme. If you've never been exposed to it before (as I haven't), Scheme may seem strange and unnecessarily arcane to you at first. However, after doing it for a bit you will realize (as I have) that Scheme is amazingly flexible, succinct, powerful and unbelievably elegant. It incorporates all the features that other languages such as C++ take for granted and skip over, and exposes the real machinery behind them, without introducing a whole host of obscure syntactical details. This clarity and elegance of Scheme has helped me understand all other languages I have to deal with so much better! Thus, in presenting the topics of this book in Scheme, the authors are actually succeding in making their discussions language-independent! Truly, the difference here lies in what your goals are: if you want to program in some specific language and just memorize it, this is not a book for you. However, if you actually want to understand how that language works, this will be akin to an epiphany for you. A very good book!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book is a must have IMHO. I'm a professional architect/programmer for over 20 years, and I wish my professors could have used this book for our intro CS course! I just read this book for the first time recently (wish I found it when it came out!). I found it insightful, refreshing...and unlike some others: fun. If you care about your craft and enjoy programming, you'll want (and probably like) this book. If programming is just a way to pay your bills, you probably won't like it. It is unfortunate that many of this book's detractors apparently see value only in books that are clearly and directly applicable to their current situation and requirements. Sad really, this is a symptom of why the art of programming is a vanishing art (I refer you to the Story of Mel. Now, that's a Real Programmer). This is a book for the rest of us. This isn't a dry book (cookbook) on syntax, tricks, snippets and samples. This book captures not only the science of programming but the art; it describes the essence of programming; the philosophy of programming. I also like this book because I like Scheme (as well as Lisp, and Prolog, and ...) but that is just an implementation detail. ...and finally if Paul Graham recommends it, it has to be good ;) because he is one of the most thought provoking essayists on programming today (with a real track record to back it up).",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book is an excellent companion to The Little Schemer. TLS is a profound and witty tour of recursion theory, but does not touch on the practical considerations of creating efficient programs (and does not claim to do so). SICP provides the assiduous reader with the distinction between a procedure's definition (which may well be recursive) and the process it generates (which may be iterative). It provides the means to make informed choices about program design. In particular, the book centers on writing language interpreters, which is an excellent strategy for understanding all of the problems faced in real-world programming. Because the book evolved from an MIT undergraduate course, the exercises tend to be thematically related to engineering concerns (math, physics, etc.), whereas TLS uses food. Do not be put off by this emphasis on math applications; the book is broadly applicable to all domains of program design, and is not *about* mathematics or engineering. Then again, you might consider the book to be an engineer's approach to program design, in that its emphasis is on correctness and efficiency, and not on abstract beauty or brevity. It should go without saying that you will not get anything out of the book if you do not do as many of the exercises as you are able.",
            "review_rating": "4.0 "
        },
        {
            "review_text": "I first encountered this book while taking the intro course on computer programming at the University of Chicago. I probably devoted 20 hours a week for 10 weeks to the book, to the programming exercises, and to try to understand Scheme. I had very little programming experience, and was studying mathematics for the most part. The book simply opened a whole new world for me where programming was concerned, interesting me in the theoretical underpinnings of programming. Three years after first reading it, I'm going back over it again, trying to glean all that I missed the first hurried time around. Is it a great book? Yes. But is it right for everyone? No. I would liken it to something like Tolstoy's War and Peace: at a certain point in your life, you can read it and it becomes a beautiful epic. However, if you're too young or not mature enough, it will just be a long drag about a War that happened a long time ago. For some people, this will just leap right off as a great book, and lead them to places in programming that they didn't know existed. For others, it may take a long time and a lot of work to get much out of it. However, this does not detract or subtract from its greatness: there is something in this book for almost everyone if they but spend the time and search for it; that itself is the essense of this book's greatness.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "The reviews here that complain that there isn't anything to learn in SICP, or that there aren't any ideas, or that there's nothing but philosophizing and handwaving, are bizarre. SICP is full of detailed, complete examples of parsers, interpreters, compilers, and digital simulators. It shows how to build your own object-oriented programming system from scratch. It shows how to construct a extensible database query language with a backtracking search to find the answers to complex queries. It shows how to build an optimizing compiler. Sure, none of this is useful---if your goal in life is to grind out CGI scripts. If that's who you are, this book definitely isn't for you. But the folks who don't recognize the SICP examples as real, practical programming projects are living in a funny little fantasy world. They might use the optimizing compiler every day, but it doesn't occur to them that someone actually had to write that optimizing compiler. Nope, code generation and peephole optimization techniques are not applicable to the real world because `nobody' writes compilers. Every one of these big, complex programs is explained in detail, with *complete* code examples. You can type them all in and run them. These are big projects, and there's a lot of code, so you shouldn't expect to understand any of the examples on the first glance; you have to study it closely to understand how the parts interact. If you're looking for silly little toy examples that fit on one page, this definitely isn't the book that you want. I get the feeling that a lot of the one-star folks are after little toy examples. Maybe they want a CGI hit counter or something. I don't know how well this book works as an introductory book; I had already been programming for about fifteen years when I first read SICP. So perhaps the criticisms that it isn't properly aimed at beginners are on target. But the other criticisms, that say that ``There is absolutely nothing interesting here. Just a couple of bored MIT professors trying to teach extremely boring and pointless concepts'' really miss the mark. Sure, building an object-oriented programming system is a boring and pointless concept---if you happen to be a ditchdigger. But what if you want to be the person who constructs OO programming systems? Or what if you want to extend the OO system you usually use with new features? What if you *don't* want to open up a can of precooked beans and heat them up on the stove? There are two kinds of reviews on this page. One kind is from people who say that the book is pointless and there's nothing useful. The other kind is from people who say that the book is full of useful, concrete examples. Maybe the people who found the book useful were suckered. But how can you trick someone into thinking that something pointless and empty is actually useful? That's a hard trick to play! How could there be so many people wakling around, doing their programming jobs, *thinking* that they're using techniques and strategies that they learned from SICP, when actually there was nothing there at all? Where did those techniques come from, then? On the other hand, another explanation is that maybe those people who think that the book is pointless and empty just missed the point. That seems more likely, doesn't it? People miss the point of things all the time. They read a little to quickly, or a little too carelessly, and the explanation or relevance goes over their heads. That happens every day. When the reviewer says that `nothing in the book is applicable', that could be a problem with the book, or it could be a problem with the reviewer. My vote is for problems with the reviewer.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "So there I was, 18 years old, having been raised on a toxic stew of MS-BASIC, Apple II assembly and some MPW Pascal. My mind was poisoned. Everything I knew about programming was wrong. I read book after book on programming and CS, but none of them really seemed to make a real dent in my style. Enter SICP. In a few months, this book reshaped my concept of what it meant to program a computer. It does not spend time teaching a language; Scheme is presented precisely because its syntax and commands can be covered in about ten minutes, and its structure becomes absolutely transparent within a few days of looking at Scheme code. It does not spend time walking the reader through common coding tasks, as a Learn X In 24 Hours text might. SICP teaches the fundamentals of programming mastery. Abstraction, modularity, design paradigms, compilation and interpretation, and more topics are presented in a style which is exactly as simple as it can be, and no simpler. Scheme allows these topics to be covered without becoming mired in details which would otherwise plague the implementor. It will not show you how to write a GUI, scrape a web page, develop a social networking website or create a network server. It will, however, guide a dedicated reader through an exploration of immensely powerful programming technique, and it will prepare the reader to solve any problem in any language for the future. SICP is not a machine gun, putting power into casual hands. It is a light saber, rewarding discipline and practice with unstoppable capability.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "The reviews of this book are just hilarious; I've never seen a book with reviews so sharply polarized between one and five stars. I think the reason for this is that most of the one-star reviewers had this book rammed down their throats in an introductory CS course, and it blew their minds. This doesn't surprise me; despite the fact that the book is meant to be an introduction to computer science, for most students it will be just too abstract and too difficult. I've been programming for over ten years, and I had to work really hard to understand a lot of the concepts presented here. Nevertheless, I think this is a great book because it discusses lots of ideas that receive inadequate or no coverage elsewhere. The material on compilers, for instance, is difficult (and idiosyncratic because they're compiling scheme, which has its own pecularities compared to, say, compiling C) but if you can work through it you get a pretty deep understanding of what's going on, without having to get bogged down in parsing or other trivial stuff. My suggestion: DO NOT read this book if you are just learning how to program; come back to it after a few years of experience and it will stretch your mind. Also, if you're having trouble I recommend Harvey and Wright's \"Simply Scheme\" as a much gentler introduction to the same material.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "The phrase 'two cultures' is usually used to describe the gap of understanding between the arts and sciences but reading the previous reviews it seems we have two cultures in the programming community. I think this division is between those who view programming as a pragmatic activity and those who also see the beauty of the underlying mathematical ideas. I agree entirely with the previous reviewers who say this book has no practical point, for 99.9% of programming they are right. BUT they are missing the point big time. The ideas expressed in this book are beautiful and interesting and that is the point. The vast majority of programming books are workaday volumes with no more aesthetics than Roget's thesaurus. This is all the more reason to treasure this unique book. In summary if you're mathematically inclined programmer and you're prepared to exercise your brain then this book will give great pleasure.",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=9",
    "reviews": [
        {
            "review_text": "whats this programming thing all about? thats what I thought mid-way through a business major in college. so i grabbed this book, because I'm a snob and I thought MIT, comp sci book, this should be a good, definitive introduction. i read parts of the first chapter. and found myself fascinated. i got sidetracked, finished my finance degree, dabbled in some comp sci classes and c++ books. Then I returned, mature enough to read the complete book. It was amazing, inspiring. a whirlwind tour of interesting ideas in computer science. it taught me what a program was capable of. I was so inspired, i set out to become a programmer and took some more computer science classes. Start work as a programmer. but if i had never read SICP, and just learned from my classes and co-workers, computer science and programming would be a drudgerous, pointless task to be outsourced to offshore developers. instead, despite the tedium of having to support poorly designed applications integrated with poorly designed third party software, reading stacks of technical documentation, i continue to be inspired by sicp. it teaches me that there are so many ideas to be explored. that the computer and the software it runs isn't just a filing cabinet or a business process automator. its way to explore problems and think about them. cooperatively with users and designers. chapter 3 and 4 i keep find myself revisiting. i often find myself thinking about them, grasping them a little deeper each time. i still have some ways to go in be able to actual apply the ideas from the discussion of streams vs mutable objects at teh end of ch 3. i wish i could spend my whole career applying the ideas from the event propagation system, the constraint network, the non-deterministic solver, and the relational programming to different problem domains. i'll try, but you also run into limits with users. users can understand and conceptualize filing cabinets / data entry systems. they have problems when you start talking about more abstract systems. i like the conscious decision to not waste time talking about class hierarchies. i love the idea of beign treated like a designer, and being walked through so many different aspects of how things work with prototypes. its almost spoiled me. whenever i see a new system now, i often find myself asking - walk me through how this thing works from the inside out. closed source systems annoy me because of SICP. thank you for writing this inspirational book!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Unfortunately, most of the computer books that I read focus on cookie cutter solutions to problems. As a professional software engineer, I dont just want \"howtos\" for a small collection of problems. SICP goes a long way to expanding your capacity to solve problems in a timely fashion. Be prepared to work! This book is very knowledge dense, and each exercise pays large dividends for the time invested. From a programmers point of view, you will fall in love with scheme very quickly. Keep in mind this book is about the larger art of programming and not just scheme. It just happens to be a powerful language for expression of high level abstractions and ideas. If you are tired of books that teach syntax and simple solutions, and you are ready for the next level in skill development, read SICP and do the exercises. It will become one of the most rewarding experiences of your software carreer.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "The comments written about this book on this site are glaringly stupid. One guys writes, \"one of the assignments is to write a scheme interpreter in scheme! How much dumber can you get?\" Well, obviously not much dumber than you. You don't writing a think meta-circular interpreter would teach you anything about computer languages? (Isn't that the point?) Or programs expressed at the most mathematical level possible? You probably don't think learning about recursion is very important either. Oh yeah, that's just something you had to learn about when there weren't loops. Obviously, if all you do is hack perl scripts, don't buy this book. If you don't want to learn something really important that requires doing things a different way other than to which you're accustomed and getting at the basis of things, don't buy it. The fact that the material in this book is taught to freshmen at MIT and Berkeley and other top computer science programs in the nation might say something to you. It may come off as archaic and worthless to some, but that couldn't be farther from the truth. The more I reflect on the things I learned from SICP, the more I realize they are important. The lambda calculus and scheme are simplicity and elegance at their finest. The difference between the understanding those people have of this material and that which is illustrated by the comments by 'programmers' here reminds me that they're right, this book isn't for programmers. It's for people who want to learn computer science.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This is a wonderful text that introduces the reader to the theoretical side of computer programs. It explores the functional, imperative, logical, and other timeless paradigms in a well-presented manner. The book uses Scheme as it implementation language. I think that some of the negative reviewers missed the point of the book. The point is to understand the theorical under-pinnings of programming language paradigms. I believe that some of the negative reviewers felt that the book was trying to push Scheme as a language of choice for programming on the job. This is not the case, but rather the authors choose Scheme because it is easy to learn and can readily be used to exemplify the major programming language paradigms. I feel sorry for those who missed the point of the book, for they have misunderstood a true gem.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I think its fascinating that there is such a split between those who love and hate this book. For most books, the review is a bell-shaped curve of star ratings; this one has a peak at 1, a peak at 5, and very little in between. How could this be? I think it is because SICP is a very personal message that works only if the reader is at heart a computer scientist (or willing to become one). So I agree that the book's odds of success are better if you read it after having some experience. To use an analogy, if SICP were about automobiles, it would be for the person who wants to know how cars work, how they are built, and how one might design fuel-efficient, safe, reliable vehicles for the 21st century. The people who hate SICP are the ones who just want to know how to drive their car on the highway, just like everyone else. Those who hate SICP think it doesn't deliver enough tips and tricks for the amount of time it takes to read. But if you're like me, you're not looking for one more trick, rather you're looking for a way of synthesizing what you already know, and building a rich framework onto which you can add new learning over a career. That's what SICP has done for me. I read a draft version of the book around 1982, when I was in grad school, and it changed the way I think about my profession. If you're a thoughtful computer scientist (or want to be one), it will change your life too. Some of the reviewers complain that SICP doesn't teach the basics of OO design, and so on. In a sense they are right. The book doesn't directly tell you how to design and write an object-oriented program using the subset of object-oriented principles that show up in the syntax of Java or C++. Rather, the book tells you what those principles are, how they came to be selected as worthwhile, how they can be implemented from the ground up, and how a different combination of principles might be more appropriate for some particular problems. This approach requires you to understand the range of possibilities, and to think about trade-offs as you go through the design process. Programming is a craft that is subject to frequent failure: many projects are started and abandoned because the designers do not have the flexibility, experience and understanding to come up with a suitable design and implementation. SICP gives you an approach that will succeed, but it is an approach based on principles and wisdom, not on a checklist. If you don't understand the principles, or if you are the kind of person who wants to be given a cookbook of what to do rather than to think creatively, or if you only want to work on problems that are pretty much like the problem you worked on last time, then this approach will not work for you. There are other approaches that will be more reproducible for a limited range of simple problems, but there is no better way than SICP to learn how to address the truly hard problems. Donald Knuth says he wrote his books for \"the one person in 50 who has this strange way of thinking that makes a programmer\". I think the most amazing thing about SICP is that there are so FEW people who hate it: if Knuth were right, then only 1 out of 50 people would be giving this 5 stars, instead of about 25 out of 50. Now, a big part of the explanation is that the audience is self-selected, and is not a representative sample. But I think part of it is because Sussman and Abelson have succeeded grandly in communicating \"this strange way of thinking\" to (some but not all) people who otherwise would never get there.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Barry Mazur (talking about mathematics, not programming) once characterised the encounter with a genuinely new concept in terms of Gabriel Garcia Marquez's experience on reading the first lines of Metamorphosis, when he literally fell off the sofa in shock, thinking 'I didn't know you were allowed to do that'. I still remember the same shock, even if I didn't literally fall of my chair, when, as an undergraduate, I encountered the first edition of this on the new acquisitions rack in my departmental library: I must have been the first person in the University, in Northern Ireland even, to read it, which I did, from cover to cover, over several days sitting in the library, even before it was released into the stacks. The reason why Structure and Interpretation is the best there is, is that it manages, not just once, but several times, to deliver that fall-off-a-chair intellectual jolt. People who complain that you can only do such things in Scheme, and therefore that the ideas are pointless, are missing the point.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This is known as \"The Wizard Book\" -- and for good reason. This book is lucid, clearly explained, and has a greater density of profound ideas per page than any other textbook I have ever seen. There is no other text which clearly presents so much of the foundations of computer science. Doing it in one semester is a frantic pace -- but it's well worth spending two or even three semesters covering it well. However, college studies aside, as a professional you will want to own this book and reread it from time to time. The stuff in it will strike sparks off the things you've been doing elsewhere and give you new ideas and perspectives -- routinely. This is an extremely valuable book to own. I've recently gotten a new copy just because mine was getting worn out -- and it didn't wear out with light use....",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This is not a book for mass consumption, as the negative reviews below (and eventually above) clearly indicate. This is a book about how to structure complexity so that it remains easily understandable and manageable. You may think this is obvious, yes? But do you know how to do it for immensely complex systems? That's what this book is about. It's the difference between being a mediocre programmer and a virtuoso. If you plan on writing code that will actually be looked at again, if you plan on designing anything anyone will ever care about, if you want your view of computational systems to change how you look at the world, this book is first on your reading list. If you want to write spaghetti code for a living, get \"C++ for Dummies\" instead.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "A truly wonderful book. What else can I say? I discovered it about 10 years into my career in software, on a recommendation from a friend from MIT where it is used for the introductory CompSci course (6.001). Originally, I didn't think a book used in a first course of computer science can contain anything I didn't know already. In the end, I ended up getting Scheme (the LISP variant used for exercises in the book) and spent almost two months working through the exercises in the book. Why? Because it challenged and changed the way I think about software. Over the years, my thinking was influenced by Wirth's Pascal (abstract data types), later by the C/C++/Java people (K&R, Stroustrup,Gosling) and the OO people (GoF). But Abelson and Sussman presented a richer and more powerful approach - software systems as layers of languages and linguistic abstractions, with linguistic abstractions serving primarily as means of formulating and exploring problems and, only then, as means of specifying algorithms for computers to execute. They get that point across by providing reasonably challenging exercises in LISP using first functional programming (the lambda is fun!!), then data abstractions and generic programming (you end up writing a symbolic algebra program), followed by objects and state (the delayed stream approach is really nice). At this point you are about half way through the book but the really interesting stuff is ahead: first modifying the LISP evaluator to implement lazy evaluation and non-deterministic computing, and finally, implementing the evaluator on register machines. While working my way through the book, I went through the MIT 6.001 course materials on the MIT OCW website, as well as the Berkeley SICP course which are both based on this book. Both courses are, no doubt, excellent, but in the end I found the best approach for me was to simply stick with the Abelson and Sussman and do the exercises.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I read and worked through many of the exercises in this book during my first year at university. It is an absolutely beautiful book that in my opinion manages to capture the essence of what Computer Science is all about. It explains what makes the magic work - it is truly enlightening. Give it your best and you will obtain a good understanding of a vast number of concepts a part from just functional programming (Scheme). Concepts like Prolog, how a compiler works etc. etc. Being in the software business ever since I graduated, I've read lots and lots of programming related books. This book however is at the very top of my list. I have had reason to come back to it over the years to get inspiration. Beware though that it isn't a casual read, it can be a bit challenging at times.",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=10",
    "reviews": [
        {
            "review_text": "Computer programmers who read this book come out changed, for the better. I've been Programming mostly in imperative languages (C C++ Java) for 10 years and have just received a Masters Degree in IT and have recently been making forays into Functional programming. This book was recommended to me. I read it. I wish I'd read it 20 years ago! I could have saved so much time and written better more powerful software. The insight I've gained into computation is staggering... it's probably going to take me the rest of my programming career to fully absorb all the pearls of wisdom this book imparts. If you're serious about computation and programming, stop reading what you're currently reading and read this first... it'll take a while to get through, and takes some hard thinking, but will inform your thinking for the better and change the way you code and think about coding forever!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "As has already been noted in other reviews, any discussion of programming languages is as prone to generating pointed, excited intercourse as a discussion of religion is. Those who think of a college education as preparation for a job have got it all wrong. It is preparation for life. Your success in life will depend on your ability to learn for you will need to learn far more after college than you did during college. Those who think that computer science should be taught in \"marketable\" languages should note that computer languages come and go. Ask a COBOL programmer. Knowing how to construct software is more important than the language of implementation. My brother is a software architect for Microsoft and most of the people that are lucky enough to get an interview are hard pressed to write code to manipulate linked lists or trees let alone discuss these most fundamental data structures! Computer scientists in academia do all of us out here in the real world a great disservice by foisting upon us this confusing melange of mathematics and software engineering. I find the two years devoted to learning calculus and differential equations more pertinent to mechanical and electrical engineering when logic, discrete mathematics, algorithm analysis, and automata theory, which are more appropriate to software engineering, get short shrift. SICP is an excellent step in this direction and scheme is an excellent vehicle for discussing these concepts and more. Furthermore, these concepts can be developed with a lab-oriented, engineering approach. Contrary to the beliefs of some, any algorithm can be implemented in scheme. What sets scheme apart from other languages is that a scheme program can then be devised to analyze that algorithm giving a rigorous and concrete development of the analysis of algorithms! When it comes to software engineering learning a computer language should be the most trivial of tasks. If you can't implement a software design in the language chosen, you will be without a job. This book is by far the best for learning scheme and the fundamentals of programming and it is already considered a classic. There are, however, less challenging ones such How To Design Programs and Simply Scheme. If you find learning scheme to be difficult then you should expect learning any computer language to be difficult. For those that think the language of the day is a route to a job you might find a shorter program at a community college more suitable. Community colleges are geared towards supplying people that meet the needs of the market today.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This is the bravest book on programming I have read. I say bravest because, rather than use Pascal or C and give you the topics \"you must know\", the authors broke free from tradition. They use Scheme, a language of astonishing flexibility and uniformity, and they show you the topics they believe are beautiful and will enlighten you. The result is a book that makes you think hard, and poses deep questions. If you are the type who likes thinking about the \"foundations\", this book can be a revelation, no less. You don't need previous experience or helper books, all you need is contained in this one; but you will need to work hard, and even take breaks, as the pace becomes very hard by the last two chapters. The book is beautifully written, though not adorned, and it provides you with a vocabulary and ways of thinking that will become indispensable, and that are rarely found in other books. Good luck!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Just read it, great great book with lots of insight. If you are one of those poor programmers that just want to cut code and get home this is not for you. If you are like me and still love what you do, if you are thrilled at the idea of 'having' to learn a new language to get a job done, love to discover new tools that make you even faster, love Knuth and the dragon book (Aho, Sethi, Ullman), then this book is for you. It really is spiritual, almost every chapter gave me that 'yes!' moment. I would also recommend watching the online video class taught under the same name from MIT, they are free online and on youtube.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book is not about learning lisp. It's even only fringely about learning how to program. What's contained in it is more than a simple description of abstraction, or modularity, or anything else you'd find in an introductory text. It even escews talking about those concepts in their simplest form to a degree. It approaches them from a 50,000 foot level, discussion how everything is an abstraction, and by layering these abstractions we can build comprehensible programs. This book has the possibility to change how you think if you listen to it. That being said, it is _not_ a book on how to build software. I've seen many good software engineers discard this book because most of the code presented has no business anywhere near a real software engineering project. Even a lot of the concepts portrayed don't belong in day to day use. But at the end of the day, this book gets the closest I've seen to explaining the hard parts of computer science and software engineering. It's a book about patterns without explicitly discussing them. It's a book about how design software without much explicit discussion of the design process. Much like some of the abstractions and \"meta\" concepts that it presents, it's a book that teaches you how to learn how to learn about programming...",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book is filled with pompous statements and philosophical discussions. Who cares? No one. Instead of teaching really useful things, such as algorithms, or tecnhiques, the text spends huge amounts of space on pointless philosophical discussions. For example, when assignments are introduced...(e.g. x = x + 1), the authors take up a boring discussion about the conceptual difficulties and implications this introduces into the language. Again, who cares? Millions of lines of code are written in C every year and everything works just fine. You can tell from the book's preface that the aim isn't to teach you programming, but instead to philosophise about conceptual issues...whatever that means. In other words, this text belongs more in a philosophy course than in a computer science course. There's more talk here, and less real action. It supposedly teaches you how to think about programming, but that is already accomplished by C courses, which teach objects and functions. Aside from that, it does a decent job of introducing Scheme. But here again, that language is strongly tied to the book's philosophy. It is nearly impossible to write anything useful in the language, as it's designed to demonstrate some finer points of reasoning about computer science, and is not designed as a practical programming language. If you are looking to learn practical skills, don't get this book, it'll only waste your time. If you are interested in \"philosophy of programming\" mumbo jumbo, you might like this book. Although, I should warn you, the text pretends to teach both things, but does neither well. This is pure \"programming for its own sake\" type of text. If you like that, fine, but if you want to program for the sake of accomplishing something useful, there are only a handful of sections in this book that discuss anything of relevance and you'll just waste your money.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "This is the best book on programming I have ever met in my life and, most probably, will ever meet. It not only surprised me and made me think \"Oh my god, how come I didn't think this way/about these so incredibly important things before?\" dozens of times in every single chapter during every of my 3(in a row) readings of it but it actually changed the way I think about programs and the way I write them. The authors have a perfect sense of balance between complexity and importance: they never skip important things silently and they never dig too deep into dull subtleties, instead they point out the really meaningful points and either invent a solution before the reader's eyes or give clues that inspire the reader to work out the solution himself. The book does not teach most of the basic algorithms and data structures, like quicksort of graph path finding (except for several examples that fit well for the purpose of a particular chapter), it is not a programming reference: it is a manual on methods of computation: exactly what the title says. So, in case you have a pragmatic problem you can't just take the book and find a solution: I guess this is the reason for low ratings. But if you read the book thoroughly, you will definitely become an order of magnitude better programmer and that is much more important than knowing concrete algorithms. I also extremely highly recommend the same-named video course by the same authors at [...] : I first was intrigued and shocked with it and only afterwards saw and immediately bought the book. It is a pity I have not yet had time to watch all the lectures (I watched about a half).",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I didn't know true beauty could exist in this ugly world but, sicp proved it's possible. This is precious. This must be protected.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I fall between the polarized views of the reviewers of this textbook. This is a well-written introduction to Lisp programming and Scheme, and introduces many important concepts in Computer Science. The problem with it is that it is not a suitable book for a beginner -- I don't consider it a gentle introduction to computer science -- and for someone experienced enough to be comfortable with its ideas, it doesn't introduce many interesting ideas until Chapter 3. Unlike other people I guess, I found the reading sometimes difficult, but interesting and comprehensible. I didn't learn much of anything (except Scheme) until the Brandeis course I took reached the discussion of the environmental model of evaluation. But from there on I learned some interesting ideas, especially about the interpretation of computer programs, non-deterministic programming, and logic. Unfortunately we didn't get to the last chapter on compilation, but I might look at that this summer. At Brandeis University, this is the second course in the major, not counting two optional intro courses which are designed for non-majors and people with little background who want to be majors. But even with the interesting ideas, it was mainly Lisp that I learned, which I don't consider a waste of time by any means.",
            "review_rating": "4.0 "
        },
        {
            "review_text": "This book explains every concept about programming languages, thus, it can represent every single compiler there is out there. Most people who gave a rating of 1 star just wants a solution to the problem. They want to have a working function without fully understanding the components of the function and what it actually does.",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=11",
    "reviews": [
        {
            "review_text": "Read this book if you want to understand the difference between \"coding\" and \"software engineering\". Read it if you believe that, in order to master the craft of computer programming, it is necessary first to understand the principles that underly how we use computers to automate reasoning. Do not read this book if you just wanna \"write code\". Such readers will not understand the book, and it will just frustrate them. Instead, read any one of the many books with titles like \"Teach Yourself C++ in 21 Days\". And judging by some of what the negative reviewers have said (\"scheme doesn't have iteration, just recursion\", and \"just a lot of theory\", and \"learn a more common language like C++\") if you do not understand this book, do not ask me for a job. Instead, go on believing that today's most fashionable language is superior to all others and that learning syntax is the most important thing you can do. This is a challenging book. It is not a cook-book of algorithms, and it does not contain one example that people who advocate practice over theory would label \"real world\". Instead, it gives readers the mental tools to create algorithms when the cook-book is inadequate. But it ain't perfect. With the exception of one small example, the book does not go into the compromises that digital computers make (precision in floating point math, for example).",
            "review_rating": "4.0 "
        },
        {
            "review_text": "SICP is an excellent, perhaps the best, advanced introduction to computer science and programming. It covers topics such as functional abstraction, data abstraction, OOP, program design, constraint programming and logic programming, always from a language design point of view. You will need a decent mathematical background to follow it. If it's such a great textbook, then why half of the reviewers hate it? Elementary: SICP is not just a textbook, it's also a Computer Science aptitude and vocational test. If you read it and like it, then Congratulations! You are a real programmer and computer scientist, with hair on your chest. If you don't like it, then you should be studying something else. Law, mortuary science, whatever, but not CS.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book might be a good read if you are at the beginning level or have at least ten years of computer experience. Don't read it in an intermediate state. Also it is the type of book that is a great enjoyment for people with idle brainpower. To be a successful professional in the computer field it is not necessary. It maybe even misleading. Here you have to manage solid day-to-day work and not feel like an inventor of a new language. Prerequisites for the book are some interest in philosophy and linguistic and a slight remembrance of a few years of college math. It contains lots of small intellectual gems. Complete explanations of a language interpreter and a compiler are more down to earth.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "My first exposure to this book was as a freshman at MIT in '86. Since then I've been exposed to an awful lot of computer science books. And I'm afraid the term \"awful\" has applied all too often. This book still stands out in my mind as one of the best comp. sci. texts I've ever read. It encompasses so many different areas of computer science that it has only been when I reread it years later that I really appreciated the full scope of the topics the book hits. Every footnote seems to branch off into another interesting facet of comp. sci. It is a bit challenging (it was geared to MIT students) but is definitely worth the read. If you get it make sure you track down MIT Scheme, the language used throughout the book, it'll help you get the most from the book, and is very interesting in its own right. In my opinion the approach the authors take is a much better one than that traditionally followed by \"introductory\" computer science texts.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This is a classic book. It's a challenging book, and I mean that in the best possible way. If you want a simple breezy book that doesn't make you think hard, this is not the book for you. If you want to rapidly understand more sophisticated topics, this is a very good book.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Frankly, I'm appalled at the elitists comments made by many of the 5-star reviewers. It's that very superior attitude which prevents the comp-sci field from creating more scientists rather than code monkeys and justifies poor pedagogy and technical writing for the sake of \"scientific integrity.\" SICP is neither masterpiece nor pariah. No other introduction to computer science has a truer grasp of the \"soul\" of computer science. Not only that, but there is ALOT of useful theory in here, if you have the patience to look. But, the book suffers for dreadful writing and advocacy of a language that can be really quite a horror for beginning programmers. On one hand, the authors took an approach that should have been brilliantly successful. On the other, they did a terrible job explaining fairly simple ideas (or, rather, ideas that should have been simple.) But, the truth is SICP has SO MUCH to offer. Unfortunatedly, the book is only as educational as the CS professor who teaches it. It turns out that the Berkeley professor who said that SICP is \"the greatest CS book ever written\" is the finest CS teacher at Berkeley. Unfortunatedly, most CS professors are not even 1/10th as good as he is and therefore help make SICP a tortorous excursion. As a EECS major at Berkeley, I've come to realize just how important theory is in the field of CS. And to that end, I think it is as easily critical that theory should be taught with the utmost respect, not only for the field but the students. SICP is a brilliant master, but often a contemptuous teacher.",
            "review_rating": "3.0 "
        },
        {
            "review_text": "The material in this book may be fun for some and boring to most, but if looked at objectively, this title does a pretty bad job of explaining most of the concepts that they try to introduce. Some things are dwelled on for so long that the reading becomes tedious, and some are covered too quickly. The last chapter, on register machines, is completely out of place. It belongs in a book on assembly programming and is a complete turn in the opposite direction from the rest of the book. In short, this title hopes to be the programming bible, but it never actually gets there. Many empty words and pointless discussions that lead nowhere. Unless you are absolutely in love with philosophical discussions on programming, and thus can put up with a bad presentation, don't get the book.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "SICP is a great book. If you are a patient reader and willing to work the exercises, then this is the single best book you could read about programming in general and about the Scheme dialect of Lisp in particular. I found it well-written, thorough and clear. Read this book with an open mind. It is not \"Teach Yourself Programming in 21 Days\". Many people don't appreciate programming theory; they would rather get on with it and start programming. If you are one of these, then you may find yourself irritated by the theory SICP includes. However, if you want to excel as a programmer it is worth taking the time to learn the theory. Some ideas may penetrate slowly but when they do, the rewards will make up for the effort. This book can be used as an introductory computer programming text, but I suspect that students won't get full benefit until they have a couple of years of programming experience under their belt. This book will make you a MUCH better programmer--something that the many books that teach a programming language but ignore computing principles can not do.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Great computer science book overall. I really wish I had read this years ago. This book gave me a lot of insight into concepts that I thought I already knew. There are some bad reviews here on Amazon which are a little hard for me to understand. I can certainly see how this book isn't for everyone - it requires a certain way of looking at things. But then, computer science itself requires that same way of looking at things. If you think Java is a great language for teaching computer science, you won't like this book. But please reconsider your career choice. (And I can't help but address the assertion in one of the reviews that \"virtually every conventional algorithm is NOT implementable in scheme\". Obviously this is completely and laughably false, but I would absolutely love to know what the reviewer was thinking - how could someone get such a ridiculous idea in his head?) I do have a few problems with the book. Firstly, the book fairly often describes a few procedures to you, and then wants you to complete exercises using the procedures. But you have no actual implementation of the procedures, and thus you cannot run any of the code you are writing (sometimes hundreds of lines). Frankly, this sucks. One of the great things about computer science is that you get immediate feedback when you code. You write it, run it, bam, there's your result. In most cases, the book does eventually give you the implementations for the missing procedures, but in at least one case, it does not. Another problem with the book is that it does not provide answers for the exercises. This is unfortunately a common situation, not just in computer science. This is probably OK in a classroom setting, but what about us autodidacts? I'm not sure of the answer to a few of the open-ended questions in this book and there's basically no way for me to find the answer. Lastly, considering the book is supposedly an \"introductory\" computer science textbook, it's too bad it's not quite suitable for someone who is smart but who has no programming experience to just pick up and use directly. There are too many peripheral issues not addressed for such a person. I do consider these serious problems. The fact that I'm still giving the book 5 stars shows how good I think it is despite these issues.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "i am a UCberkeley Electrical Engineering and Comp sci major... a person that would much rather be out \"swing\" dancing or hiking...however this book was so intriguing that i needed to dedicate my weekends learning philosphy of computer science(versus computer programming)... I loved it..the time passed by... the exercises were fun and interesting...the reading was hard, but its a rewarding path! This book definitely helps you condition your ability to define problems and solve them :-)",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=12",
    "reviews": [
        {
            "review_text": "I've been a professional in the computer science industry for years, and I still find new gems, leading to ah-hah! moments, each time I pick this book up. Saying that I underappreciated this book when I first read it is an understatement. Based on many of the reviews here, I suspect this is a common phenomenon. Those who care deeply about computer science love this book; those who see this book as the only barrier between them and a passing score in their current CS course clearly do not. This book teaches you to think about problems in a different way, a way which stays with you forever. I guess LISP is like that in general. The mechanics and specific techniques are not as important as comprehending the entire material at a higher level. Read it once, read it twice...heck, read it once a week from now until you die. I plan to.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Vibrant cover and print seems to be fine. This is a classic. I'm building a collection of programming books, and I read some reviews about the hard-cover print having issues with the glue on the binding... So I bought the paper-back and I'm pleased with the quality.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I'm assuming this book is intended for beginners, since those who are advanced will only be wasting their time reading this childish text. If you're a beginner, starting to learn programming by reading this book is like discussing the next major physics theory without know any physics. You'll learn to philosophize and throw around grand but meaningless ideas. Starting with C and machine organization books (i.e. assembler) is a better way. You'll learn the internals first, find out what's behind programming. You'll know how procedures are actually called, and what some of the issues are. Than you can read books like these. In fact, towards the end of chapter 4, the authors themselves admit that their simplistic view of computers and languages is severely deficient if they want to descirbe things properly, so in ch.5 they introduce register machines (i.e..they teach you abou how CPUs work). Beginners learning from this text is akin to space scientits planning a complex trajectory, and than getting down to learn basic Newtonian mechanics. No wonder so many beginners I've talked with complained. They couldn't understand what all of this encapsulation meant, since they had no idea of the basic underlying process--simple pushes onto a stack and jmp instructions. Aside from the book's wrong approach, it's also terribly written. I tired to like it, but books can only be so boring before you start to feel aversion towards it.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "This book, quite simply sucks. I opened it up looking for good advice. Instead, I find discussions that lead nowhere, or if they do, they are very boring. For example, is it really necessary to discuss modularity and abstraction? Isn't it a bit obvious to anyone who has programmed even a little that breaking programs into manageable pieces is a good philosophy? That was the only concept treated that has some relevance to programming. Other topics, such as streams, logic programming, evaluators are all either useless, or presented so poorly, you'll definitely be better off reading specialized books on those topics. This book isn't good for beginners either. It's just too complicated.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "I was hoping, based on the comments of some people, that this book would be somewhat of a bible for programming...they said it's the best book of programming ever written. I was quite disappointed. One of three things usually happened when I read about a new topic in this text: 1. I already knew some things this book talks about. They are, in fact, fairly obvious, like abstraction. 2. The idea was fairly interesting, but it wasn't possible to implement it outside of Scheme. In other words, this idea became useless. 3. Some things were just a pointless waste of time. Purely philosophical discussions. In short, this book told me nothing new. A huge disappointment. I don't understand what these people see in it.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "This is a 'must have' book for anyone wishing to practice the craft of programming. It is enigmatic in that it requires little background in programming, but leads swiftly and easily into non-trivial concepts. Of course one must do the exercises, which are varied and practical, the most they ask of the reader is that they understand basic mathematics of Leibniz and Newton. This book will not teach you a collection of tricks, it will give you a way to think about programming. There are a set of lectures by Abelson and Sussman based on the book available at no cost on the Web. Even though they were produced over a decade ago they are well worth watching, and add an interesting flavour to the text. All the software you need to use this text is available for free for a number of platforms. If you are an experienced programmer this is a fun read, if your intention is to learn the art of computer programming, start with SICP, and add Knuth to your bookshelf for reference.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Spent a month for this and done most of the exercises. I remember almost everything about this book`s lesson, but I still can`t define what I have learned. The only thing I sure about is that SICP is a brilliant and unique tour guide.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "If you disagree, hopefully you're thinking Knuth . But consider this: Knuth is a wonderful bestiary of important programs and proofs; SICP is about the very nature of programming and programs. If you're not thinking either, and no offense to K&R et al: Do yourself a favor, watch the videos. Sussman & Abelson are entertaining teachers. SICP is a difficult book, and seeing Sussman in a fez after the metacircular evaluator just... helps. But of course Graham's and Norvig's reviews are gems of their own.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "The negative reviewers entirely missed the point of this book. The issues are not c++ versus scheme, nor the gap between the book's examples and real-world programs, nor that recursion is less intuitive than looping. The real point is to teach some very core foundations of computer science that show up everywhere. For example, supposedly revolutionary XML looks a heck of a lot like a nested scheme list, first described in 1960. And processing an active server page (or Java server page) is very much like the textbook's specialized language evaluator. Finally, c++ polymorphism through vtables and part of Microsoft's COM mechanics are the exact same thing as the book's data-directed programming section. This is very deep material for a programming newbie to learn outside a course, but for an experienced nerd who's looking for a systematic framework, it's absolutely terrific. I had done lots of lisp and compiler work before reading the book, so many of the concepts were not new. But it's with this framework in mind that I learn new technologies, and this approach greatly speeds up how long it takes to understand each week's \"new\" hot product/language/tool/mindset. Put another way: why do so many popular computer books take 1000 pages to describe a few trivial concepts?",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I found this book in a dark corner of library and tried to read from beginning to the end. My reading progress became slower and slower and discontinued in the middle. This is not an easy-reading book, it is better for education purposes and passionate people. But the ideas presented in this book are pretty cool, never thought of programming can be done in this way. For readers who is keen to read this book, recommend watching MIT's SICP open course: [...]",
            "review_rating": "4.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=13",
    "reviews": [
        {
            "review_text": "I originaly was introduced to this book in college by a teacher who said the text would open heretofore unknown vistas to me. It was supposed to turn me into a deeply understanding computer scientist, and not just a code monkey. I found out those promises didn't come true. Two semesters later I was feeling lucky to have finally finished the course, and was angry to have wasted so much time. This book quite simply doesn't deliver what it promises. Instead, it tries to be as coprehensive as possible, covering so many topics that I was dizzy, but it does a very bad job of explaining anything in detail. The end result is that I learned nothing. Apparently the authors believe quantity is better than quality. In any case, you won't get anything out of that text...and it certainly won't make you a better computer scientist, though it pretends to. Don't waste your time and money.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "The 1 star reviews show what is wrong with education in general and computer science specifically. They give credence to Spolsky's conjecture about Java schools. Computer science is a mathematical discipline, people complaining about math do not belong in this field. People who claim that certain algorithms can not be implemented in Scheme need to either start paying attention in class, or switch to a business program. This is a freshman level textbook. The theories in this book are not arcane nor irrelevant. They are what is necessary to truly understand computation. That so many people think otherwise is not surprising given how terrible the vast majority of software is these days. This book is well-written and engaging. It gets to the point and gives great examples in a language that everyone should learn. If more people understood lispy languages and functional language concepts it would be much easier to find competent programmers, even if they are being hired for projects that use clunky languages like C, C++, Java or C#. In short, the concepts in this book separate the CS professionals from the API monkey.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book is to Computer Science what the Feynman Lecture notes are to physics: an introductory text that could reshape the mind of the average PdD. It's not about Lisp, it's not about Scheme, it's about computing at the most fundamental levels. If you're an experienced programmer, it will change your way of thinking forever. If you're a novice, it will set you down the right path. Read it and work through every problem. Repeat every few years.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "The best textbook ever written to teach computer programming to college freshmen, though somewhat difficult for the non-mathematically minded. Exposes the basics of programming in a clear, elegant way, starting from simple procedural and structural abstraction up to virtual machine, interpreter and compiler design, through object, concurrent or logical oriented ways of programming. Exercises are rather stimulating, and actually doing them is more than half the substance of the book: it's not a book one merely reads, it's a books one does. Although intended for students of Computer Science, this course should appeal students of all engineering branches, because the principles taught are not only relevant to the art of computer programming, but also to the design of all kinds of complex systems. If you need only one introductory book about the subject, try this one.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "SICP takes you to the heart of Computer Science. It teaches you to be a computer scientist, not a programmer. This is a book that you read in your spare time, not when your have a project due in two weeks (or a final tomorrow). It is more philosophical than practical, and is for the aspiring computer scientists rather than those who need to get out there to make some money and buy stocks. And it is quite advanced in theory for an introductory text. Beginners are better off with books that approach these ideas from a practical programming perspective.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Structure and Interpretation of Computer Programs (SICP) is one of the best book on computer science.I've here found a well number of peoples who have rated the book as 1 but I can't understand why? Actually those people either thinks computer science and mathematics are different or they need some spoon feedings on the subject.Computer science(as the book suggest) is the field of Imperative Knowledge and Mathematics is the field of Declarative as well as Imperative knowledge.Now why you need Math in Computer Science? That's because, suppose you have designed some algorithms or data structures or a new computational model, but how can you prove that the designed Imperative Knowledge is true or false? Then you need Declarative Knowledge i.e. Mathematics and for this reason only every field of science and engineering requires a very firm grasp in mathematics.This book is not for mere programmers or casual computer science student, this book is for Computer Scientist or for the students whose aim is to become a serious computer scientist/engineer.And lastly to understand this book you should be very sharp at mathematics,at least to first order logic and always keep in mind mathematics is an inherent part of computer science and this is the only reason that most of computer scientist till to date have conventional degree in mathematics including Dennis Ritchie the creator of C language and there are some beautiful books as \"Concrete Mathematics\" and \"Algorithms\" by Donald E Knuth[have degree in math] and \"Introduction to Algorithms\" by Coreman et all[all those respected MIT professors have degree in Math].",
            "review_rating": "5.0 "
        },
        {
            "review_text": "People told me this book was B.S. , so I went throught the entire course without reading it and going to lecture, which worked splendidly. I got this book at another store at the very end, just as a curiousity, and promptly returned it when I saw just how bad it is. Confusing, pointless, dumb. This isn't about the value of fundamental knowledge of computer science anymore, the book is outright poor as a teacher. I'm sure there are other books on philosophy of computer science which will teach you a lot more. This one is just a waste of money.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "The book promises to make a better programmer out of you, to teach you how to think about programs, but this promise is not kept. Those things which it presents that are relevant to overall philosophy of programming are already widely know as it is. The other things they present are completely useless. In short, you will not gain any valuable insight and won't see any revelations or any radical and vastly superior methods of thinking about programs. It's just mundane drivel here. To top it off, the book is very dry. I'm extremely interested in theoretical computer science and this book managed to bore even me. You'd need a lots and lots of patience to get through even a fraction of the material here. I wouldn't recommend this title to anyone.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "Regardless of what you think is useful computer knowledge, this book does a bad job of presenting its topics. Especially for beginners, this book is very frustrating. The first few chapters often employ obscure mathematical tricks as examples of how the computing concepts can be applied. In the end, the reader doesn't see the forest for the trees and tries to figure out the math just to understand what the code samples are doing. Other parts of the book either mention in passing, or devote very little space to interesting ideas, and instead devote pages and pages to something fundamental, to the point that it gets very boring. Finally, I personally think this book is poorly organized. The first four chapters try to focus on maximum abstraction, and the last chapter presents a totally oposing view of computers--as register machines...which is a completely different paradigm. This confuses many people. I'd give this book zero stars if I could.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "Whew! I just got done with the finals in scheme. This book contains a great deal of information. Some of my favorite topics in it include the huffman algorithm, and the streaming. I think I learned a lot from this book and the biggest gain I had was the grasp on recursion. Iteration is awesome because I have done c++ before. Recursion always gave me a nightmare previously. This book introduced us the idea of head, tail, and tree recursion. Once we got deep I got pretty good at recursion. The book taught me how a program gets evaluated using environment diagram. It had a lot of examples and presented students some kewl theorems. I will definitely Keep it next to my bed.",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=14",
    "reviews": [
        {
            "review_text": "If you read books carefully and try to understand their meaning, you'll be frustrated by this text. If you read 'popular' books as a 'trophy' collection activity and don't think about content...this book is for you. It's from MIT..all the prestige you need in one little text...who cares about the actual conent? Those who do care, stay away. Some of the most fundamentally important material is gathered here and butchered in the most horrific way. I suggest you look at specific books on topics such as hardware design, compilers, etc...this book will only cause pain and won't explain them.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "This book is readable. I can't say it's fun or easy to understand, but a *few* concepts might seem interesting. However, the large majority of things introduced can't be applied. Streams, for example, are introduced to alleviate the bottlenecks created by Scheme in conjunction with poor code planning earlier in the book. They are completely irrelevant to languages like C/C++. The same with other things here. Mildly curious but nothing useful and certainly no profound theories, as some would have you believe.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "It's amazing how polarized the opinions on this book are. I personally consider it a landmark book, but that's almost irrelevant given the controversy created by the reviews I've seen here. I've read this book when I was already an experienced programmer and I can say it was truly inspirational. I can imagine it can scare beginners, or render the snooty ones angry. I think the best way to figure out what *you* would think of the book is to take a look at it yourself. This is now easy because the full text is now online - you can find it easily by searching \"sicp\" with google. The current address is mitpress dot mit dot edu slash sicp.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Harold Abelson created a great book. Pinecone Bookshoppe are dishonest sellers.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "If you can't afford this book then steal it from somebody. Reading and understanding this book is a rite of passage for real programmers. Then read \"No Silver Bullet: Essence and Accidents of Software Engineering\" by Frederick P. Brooks, Jr. and \"A Relational Model of Data for Large Shared Data Banks\" by Edgar F. Codd. Reading and understanding these 2 papers is a rite of passage for successful software engineers.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I have almost finished reading this book. it is difficult, isn't it ? Seriouly, it is an engineer-oriented book - many example/application to use the scheme, but no theory. Maybe, the auhtor wanted you to learn the scheme language, just exactly like the way you learn the natural language. But, there is really easier mathematical way to learn the computer languages, more clearly, quickly, efficiently. I strongly recommend that you read McCarthy's paper \"Recursive Functions of Symbolic Expressions\" before diving into this book, which is much rewardable. Scheme is small, while powerful, because it is based on the solid mathematical foundations.",
            "review_rating": "4.0 "
        },
        {
            "review_text": "This book is good to read when you have trouble falling asleep. Everyone I know, including the professor, were often confused. In the end, he abandoned the book and started teaching from his own notes, and learning Scheme and the concepts became a pleasure. The problem is the author, who thinks that because he's from MIT, he can just write drivel and it will sell. Everything in this text can be explained much more clearly and precisely if done by a good teacher. But the book makes no such effort, and as a result, it's boring and often difficult to understand. If you really want to learn the foundations of programming, buy a book by Knuth, for instance. SICP, though, is probably the worst, most arrogant and pompous text on programming, but it teaches nothing.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "I have very mixed emotions about this book. On the one hand, it is perhaps the best introductory work on the philosophical and theorectical issues of computation, dealing with many concepts that normally are either taken for granted by most programmers, or else are completely unknown to them. If you get past the dry, analytical tone (and the rather flat punnery), it actually becomes quite engaging. It is a book that demands careful thought on the part of the reader, and can reward dilligent and thoughtful study. It scrutinizes even such seeming obvious concepts as recursion and assignment, and often reveals a great deal of hidden complexity to them. However, by itself it is not a very good primer to progamming, either in theory or in practice. The examples given are often unnecessarily tortuous, especially given the imperative to teach strict functional design in the first several chapters. Too much effort has been given to keeping it at 'pure' and 'general', and there is little attempt to connect the important ideas with how they appear in actual use. Among the flaws is too great a concern with language independence, and specifically, an obsession with presenting the fewest possible language constructs needed to achieve a given purpose. It makes no attempt to present the Scheme language itself except where it is absolutely necessary in order to give an example; while this is done to keep the discussion as general as possible, it often has the effect of confusing the student. Many example programs which would be crystal clear with the use of certain language facilities are made hopelessly incoherent because the authors wanted to enforce 'language independence'. Also, because many aspects of the language are ignored as irrelevant, the students learn only a small part of the language itself, and are left with the impression that Scheme is a hamstrung, pedantic language lacking in many obvious features. From reading SICP, few would ever imagine that it supported strings, characters and vectors, or had an iterative construct (do), an escape mechanism (call/cc), a macro facility (let-syntax and syntax-rules), or even basic stream I/O (read and write). Scheme is a simple enough language as it is; it need not be pared down any further no matter how noble the purpose. More importantly, much of the presentation so abstracted as to be completely divorced from real practice, especially in the sections on imperative and OO programming. While this is a good thing in many ways, as it shows the conceptual underpinnings which are so often lost in day-to-day programming, no attempt is made to draw a connection between the theoretical abstractions and the concrete practices. The ideas are left floating aimlessly, and the student is left with no clue as to their relevance or value - which is a pity, because they truly are important, and understanding them can make the difference between a true programmer and a mere coder. The section on logic databases is an excellent example of this. While it presents all the elements of keys, querying, unification, etc. in a lucid, detailed fashion, the databases are represented solely as list structures. No mention of files is made at all, in this section or anywhere else in the book - the word 'file' does not even appear in the index. Nor does it reveal that most database work today is based on the relational calculus, not predicate logic. Similarly, the discussion of streams concentrates solely on their use as a way of representing change in state over time; not only are ports (Scheme's stream I/O mechanism) ignored, at no point is the student given any hint at all that the primary use of streams is for input and output. This is like discussing driving without ever admitting the existence of roads; it is abstraction run rampant. While the discussions are wondefully insightful, the student isn't given any way to apply them, even within the context of study. In the end, I would strongly recommend this book as a supplement to an introductory course based around another Scheme text, such as Simply Scheme. While I think that every serious student of computer science (as independent from software engineering) should study it, really requires the work of a gifted teacher to make it clear, and it should never be used as the sole text. It is a brillant piece of work, and a wonderful source of key insights into programming, but it does not stand alone.",
            "review_rating": "4.0 "
        },
        {
            "review_text": "As is probably obvious from the sharply divided ratings, this book doesn't appeal to everybody. For me, it deserves the full five stars. This was the *only* textbook I kept from college. My leanings are more toward the theoretical, and I'm more interested in conceptual books (like the GOF patterns book) than implementation books (like, say, K&R). I think that this is a reasonable guideline for evaluating whether or not this book is worth reading... So, I give this book five stars in terms of a theoretically oriented read, and maybe two stars in terms of a practically oriented read.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "If you read books carefully and try to understand their meaning, you'll be frustrated by this text. If you read 'popular' books as a 'trophy' collection activity and don't think about content...this book is for you. It's from MIT..all the prestige you need in one little text...who cares about the actual conent? Those who do care, stay away. Some of the most fundamentally important material is gathered here and butchered in the most horrific way. I suggest you look at specific books on topics such as hardware design, compilers, etc...this book will only cause pain and won't explain them.",
            "review_rating": "1.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=15",
    "reviews": [
        {
            "review_text": "I never heard so many interesting and different views expressed for any book.some call it a waste of time and others a classic.Some refer it as an apptitude test for comp sc and others a book that has nothing to do with modern software engineering. I think everyone is right at its own place. It all depends on how you look at things.Their is a set of inquistive ppl in the world who wants to know why and how of every thing .. why this apple is falling towards the ground and not the otherway .. isn't this a stupid question, a lil crazy for Newton to think this way so is this book. The author starts by exploring what a program is. what is data,procedure,abstraction,modularity what we can do with it .how to model systems and why ? well all these are trivial questions and why do we care..we are living in a world of MFC's,API's,Integrated Environments..True thats why this book is a waste of time and has got nothing to do with modern software engineering. But if you care why the apple is falling towards the ground and if you have the faculty to wonder you are going to like this book. It will give u insight in to the programing will make u think in terms of programming and not languages.. may be will add to ur creativity..This book is not easy to read.I think this book is equally difficult for a fresher and a 10 yrs exp guy.It all depends on how gifted u are. if u have it, it doesn't matter how many years u have put in to comp sc. If you want to make an apple pie from scratch, you must first create the universe.SICP is all about this.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "So much can be learned by reading this book. I can't begin to describe how many essential (deep) concepts it conveys seemingly effortlessly. If you haven't read the book, or used the Scheme language, it's virtually guaranteed you will learn a lot by doing so. MIT Scheme is available for free via ftp, and makes a perfect companion to this text.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This book is used as a filter in our computer science department. It subjects students to material so boring, and presented so poorly, that only those who can stand through it all ever stay on for more computer science classes. Complete waste of your time....it describes (in a confusing manner) concepts which can be better learned elsewhere. The authors apparently believe that quantity is better than quality, and try to cram a lot of material without explaining any of it in detail.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "I must say, it takes great talent to take relatively simple and curious ideas, and present them in a very boring and convoluted way. That's right, this book will make you feel pain at every paragraph. You won't learn anything either. If you are interested in theoretical side of computers, there are plenty of better books. Don't waste your time and money on this one.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "I would say only the idea of abstraction is \"beatiful\" but the rest of the book is drivel. It tries to present profound ideas, but fails miserably for lack of lively content or perhaps the incompetence of the authors as teachers. Although I haven't looked, I'm sure there are plenty of better books on the art of programming. This one is just a waste of time no matter what your interests are.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "This is one of the great classics of computer science. I bought my first copy 15 years ago, and I still don't feel I have learned everything the book has to teach. I have learned enough to write a couple books on Lisp that (currently) have four to five stars. Yet SICP, which is pretty much the bible of our world, has only three? How can this be? Reading the reviews made it clear what happened. An optimistic professor somewhere has been feeding SICP to undergrads who are not ready for it. But it is encouraging to see how many thoughtful people have come forward to defend the book. Let's see if we can put this in terms that the undergrads will understand -- a problem set: 1. Kenneth Clark said that if a lot of smart people have liked something that you don't, you should try and figure out what they saw in it. List 10 qualities that SICP's defenders have claimed for it. 2. How is the intention of SICP different from that of Knuth? Kernighan & Ritchie? An algorithms textbook? 3. Does any other book fulfill this purpose better? 4. What other programming books first published in the mid 1980s are still relevant today? 5. Could the concepts in this book have been presented any better in a language other than Scheme? 6. Who is al? Why is his name in lowercase?",
            "review_rating": "5.0 "
        },
        {
            "review_text": "i bought this after wanting to brush up on theory, algorithms, programming concepts and all the other Compsci stuff but didn't want to go back to skool. this book really helps brush up on what you need to know and I would recommend that anyone taking compsci today get this book and work thru it in conjunction with your regular classes. those of you who didn't go to compsci should get this book too. You will learn a lot..but not how to spel!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "My CS professor at UC Berkeley, introduced his course as the best CS course at Berkeley because it uses the \"greatest CS book ever written.\" For all the pain and long hours it has put me through, I must admit this book taught me concepts I never knew. This book is not for the casual reader who wants to learn practical programming, but rather for someone who wants to really be hit hard by all the important topics in Computer Science today. Good luck!",
            "review_rating": "4.0 "
        },
        {
            "review_text": "Everyday, my friends would talk about this book and remind each other to read their fare share of SICP for the day. I finally saved enough money to buy my own copy, and I'm now making sure I read a few pages a day. Best wizard book ever, as Sussman would put it",
            "review_rating": "4.0 "
        },
        {
            "review_text": "I love this book. It's fun to read the things I already know, put together in such an interesting way. If you have 10 years serious experience as a computer programmer, and love programming, this book is for you. (Five stars.) However, I really bought it to see how the masters teach introductory programming. They don't, unless maybe you have a SAT score of 1500+, an IQ of 170++, and are an MIT student being taught by someone who knows and loves this book. Otherwise, don't touch it! There are better things to do with the money: burn it, give it to the rich, or buy drugs from a narc. (One star.)",
            "review_rating": "3.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=16",
    "reviews": [
        {
            "review_text": "I was quite disappointed with this book. It starts out ok, but after the second half of section 2, the book gets to be incredibly thick and boring. I've never felt so disinterested about anything in computer science, and it's not the subjects, mind you (compilers and logic programming can be fun), but it's the dry, pedantic style, obviously written for the sake and glory of the authors and not for the sole purpose of teaching someone.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "...but only if you skim it quickly, brainwash yourself into thinking you learned a lot, and glorify this book because of its prestigious MIT roots. If you are one of those who think deep about the things you read, you'll realize most of this book doesn't make any sense. I learned the material from my college professor. (who hates the book, btw.)",
            "review_rating": "1.0 "
        },
        {
            "review_text": "If your school uses this book as a text of a certain introductory cs course that you have to get a \"good\" grade for, you definitely want to have some help to understand it in such a short time. That is, at most, a 16 week semester. On the other hand, if you really want to explore the world of programming on your time and on your own pace, it is the ultimate source of programming magic. Some people from MIT and UC Berkeley say these wonderful things about this book, yet they are only true when you are really after the knowledge not the grade.",
            "review_rating": "3.0 "
        },
        {
            "review_text": "It is a great book for the serious student. I spent much of the read-time visualizing the excellent concepts. When I finished this book, I was able to easily learn and effectively use several languages. (VB, Java, VBScript, JScript, Perl, C++) It is very import to understand that programming is not just understanding the language, but how to use it effectively. ~ Just because you know how to speak & spell in English that doesn't mean you are great writer... This book will help you become a great writer (programmer).",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Unless you are required to have this text for the course (and why else would you buy this terrible book?) don't get the text. If you have any doubts about computer science, this book will make you hate it. It tries to mold budding computer scientists by gathering the driest, most boring subjects into one monster collection. You'll probably fall asleep before finishing the first few pages.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "This has got to be the worst, most boring computer book I've ever read. The authors managed to gather the dullest material possible and present it in a very lifeless way. I had to get this book for the course (also very boring) and threw it away afterwards because no one would buy it back from me. If you love this book...you'll probably make a great hypnotist...so would the authors.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "the bipolar distribution of ratings shows how well this book separates the masters from the code monkeys. Read it. Study it. Find out which side of the fence you're on.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I had to read this book for my intro. to computer science as a freshmen in UC Berkeley. At first, this book appears quite dry and I don't understand most of the concepts. So I read each chapter at least 2 times try to figure out what Abelson is trying to explain. When I finally understand the concepts, I find it a great book for college students who what to have a soild start as a computer science major. Good luck on reading.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Superb! I wish I had read this book in my first year of computer science. I read it 9 years late! [BTW, I am a professional computer engineer.] It is the difference between memorizing multiplication tables and knowing how to multiply!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "The book is just that, a big bore. It's too confusing for beginners, and it'll put to sleep anyone who knows a little somthing about computer science. I would agree that some of the general topics presented are important, but how they are presented is a disgrace to computer science. Instead of talking about relevant ideas in compiler and language design, authors try to implement a scheme interpreter in scheme. The material was completely divorced from the real world. I showed it to my buddy, doing a Ph.D. in compiler design, and he laughed long and hard at the whole chapter 4, which also manages to completely mispresent databases and query languages. Being a grad student in computer engineering, I found something to scoff at in chapter 5 & 3, where they give a backwards presentation of assemblers, digital circuits, and circuit simulators. Come to think of it, the only worthwhile material was in chapter 2 & some of chapter 3, but that was on data structures, and Cormen's \"Algorithms\" is infinitely better. My impression is, and others have suggested, that the goal of this book was self gratification for the authors. They wanted to have a book with all kinds of stuff in there, that would be used by copycat instructors all over the world to confuse beginners and bore knowledgeable students. This book would get the prize for the most obfuscated computer science book.",
            "review_rating": "1.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=17",
    "reviews": [
        {
            "review_text": "Typeset in LaTeX. A classic. Accessible to whomever is serious about Computer Science. A great introduction to the Lisp family of funcional languages, in its modern incarnation: Scheme. What is there not to like? Nothing.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I think you'll need a good prof. to learn anything from this book. If you like to learn on your own, you'll need to find better texts that this one. It's fairly dry/uninspiring and there's a lot of fluff mixed in with a bit of interesting material here and there. I didn't enjoy reading it at all.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "Scheme and I have parted ways since I was an undergrad taking 6.001 at MIT, but the fundamentals in this book has stayed with me since. If you're really into in computer science and programming, check out this book.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I read this book because it was assigned for a course in school and I feel that working through the book greatly increased my ability. Now that school's out I find myself wanting to conjure the spirits of the computer with my spells and asking people to `read SICP' in all kinds of conversation.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "The book never lives up to all the hype surrounding it. In fact, of the over 50 people I know who had the misfortune to study out of it, none liked it. I imagine only a few crazy souls who care about nothing but dry computer langague theory would even consider this worth reading. Recursion and information hiding via procedural/object code is nothing mysterious and is taught in all other CS classes, so the text adds nothing new. It merely retells the same old obvious programming techniques using a very poorly designed language (Scheme) and using completely uneducational examples. In short, this book is an overrated waste of time. If you are familiar with structured programming in a langauge like C++, you won't get anything new out of this. In fact, any topic presented here is better learned elsewhere, since the text is just one of those poorly written books that try to be encyclopedic at the expense of being interesting and thorough.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "If you design computer systems, you will love this book. If you whack away until your program does what you want, you will think it's stupid. There are sheep, and there are goats. The goats think they are pretty much the same as the sheep. They are not.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "Scheme is a great language for writing Scheme interpreters and compilers. This book is just as self-referential as Scheme is. It is a book by MIT professors for an MIT class and is published by MIT Press. What works for a programming language doesn't work for a book. The class this book is designed for is on introductory programming. But don't expect to learn programming here. The authors have too many axes to grind to have time to worry about the best way to teach beginners about programming. They must point out that the C language suffers \"defects\" and that C programmers can be \"reformed\" by programming in Scheme. Every member of the MIT computer science department circa 1980 must show up somewhere in the footnotes, another distraction for the authors. There is plenty of good computer science here, but you already have to be a computer scientist to appreciate it. And the Scheme language is itself wonderful. Just don't try to learn it here. The teaching method used in the book is adding successive layers of abstraction. To the authors, the world beyond Cambridge, Massachusetts is nothing but a vague abstraction.",
            "review_rating": "2.0 "
        },
        {
            "review_text": "There are many things wrong with this book, but perhaps the worst is its shameless lying when the authors promise you profound knowledge of computer science and end up delivering a cheezy promotion of Scheme. They only concentrate on aspects of programming as it involves Scheme and don't make any effort to teach computer science as an art or as a science. They don't teach anything that's applicable in general, or will give you better understanding of the issues involved in writing good software. All they do is present trivial topics such as basic data structures and programming example, and it's all using Scheme. I ended up learning Scheme and nothing else. There are plenty of other good books which cover the art of programming so generally that you'll find information useful in any programming project. For example: Cormen, Leiserson, Rivest \"Introduction to algorithms\", Knuth \"The art of computer programming\" (3 volumes) ... these are all highly regarded books. All I hear about SICP from students and professors alike is that they wish the book ceased to exist. Don't listen to the others on this page...the book won't teach you to be a better programmer, and it won't teach you how to understand programs. It'll simply waste a lot of your time.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "Awesome book. This book will teach you the right way to think and reason about computation, an essential skill for any aspiring computer scientist.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "This text was written by two professors at MIT for MIT's introductory computer science course. The fact that it is still used today as the intro text at both MIT and Berkeley speaks for itself.",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=18",
    "reviews": [
        {
            "review_text": "That's right, this book is plain boring, even for a CS major like myself. I did not learn anything except for Scheme syntax. Once you get that, the rest of the book is useless. This text is a half-baked attempt at algroithms and data structures, and of course, since it's tailored to scheme, I never found much use for these concepts later. In fact, once you start programming in a real language like C, you'll have to relearn all the concepts and see how they really work in the proper programming setting. On top of that, the writers make absolutely no attempt to be clear. Because no one thought of building iteration into scheme, you're stuck with a perposterous recursion overuse, complicating many simple algorithms, and confusing even the brightest students. Even my professor didn't like the book. It has the feel of a book written for no other reason than Abelson's self-gratification. If you value your time, avoid this book. Get instead the wonderful text by Cormen, Leiserson and Rivest : \"Introduction to Algorithms\"",
            "review_rating": "1.0 "
        },
        {
            "review_text": "-- for someone who never has to deal with industrial software. But there is greatness here, so let's start with that. The book is entirely based on a Lisp dialect. That gives a very strong mathematical note to the whole text, where functions of functions arise early on. This book lays out an aggressive first course in programming, introducing valuable topics like lazy evaluation, logic programming, interpreters, and constraint propagation. These, of course, have many applications and even more implications; the base concepts are useful far beyond the case studies presented here. The students of this course also receive vivid demonstrations of the hazards of parallelism, and the merits of stateless functional programming in eliminating change-of-state race conditions. Sorry, to say, I'm not a functional programmer. I use imperative languages (call them dys-functional if you must). So do 99.9% of all commercial software developers. They're stateful languages, and reflect the fact that the world has state. It may be elegant to move back and forth along the static, four-dimensional space-time trajectory of moving objects with respect to fixed ones. In practice, however, a car ramming a wall should not be considered a reversible event. One must also note that the early versions of this book date to the 1980s, before object orientation became widespread. Even the later edition (1996) ignores the basics of OO practice, since they couldn't be captured in the version of Lisp favored here. Instead, examples (ex. p.189) propagate the pernicious practice of hand-coding polymorphism via switch statements or manual table management. I'm not an OO absolutist by any means. I'm painfully aware of its limits, and willing to recommend functional style when it solves specific problems. I am fully cognizant of the iron and silicon that lie under my program, however, and of the mutualism between hardware and software. In all the years I've been building software and hardware, I've never seen a \"functional\" computer. Sooner or later, all of them store bits - if nothing else, the functional program itself. There's a lot of good in this book, including a great example of how to design a programming course for a brilliant novice. Believe me, the smart students can be harder to handle than the plodders (but worth it). This may outstrip the plodders, though. And, in the end, it teaches only Lisp - a language with negligible presence in the working world. //wiredweird",
            "review_rating": "3.0 "
        },
        {
            "review_text": "Excellent book to teach computer programming, especially if you are willing to use Scheme.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "There's no useful material here, whatever your level of sophistication. Beginners will find that Scheme, and the book's approach in general are confusing. Those who are advanced will find the text is full of bull, and a book like \"Introduction to Algorithms\" by Cormen et.al. will provide you with many more theoretical and practical topics alike, but it's advanced (and hence more interesting than SICP drivel). If you are a beginner, \"C++ how to program\" by Deitel will teach you all about object oriented and top down programming, plus you'll learn the C++, the most common language out there. Whatever is presented, is of such poor quality, and so dry, I couldn't stay awake long enough to finish my assignments. You can learn how to be a good programmer from any computer science course or text, and there are only several sections about that in this book. If you are looking for interesting theoretical ideas, look for other texts, such as the ones mentioned above. From what I've read, I get the impression this book was written in a rush, and with the purpose of cramming tons of nonsense and filler in just to have an excuse to present Scheme (a pathetic language). The authors claim to present a view of programming that's widely applicable, and state that top-down (i.e. procedural) programming is by far not the best way to think about programs abstractly. Well, they don't stick to their promise. They present a biased, one sided promotion of scheme as the best language out there. No attempt is made to make comparisons between functional languages like scheme and normal languages like C. The end result, you come out knowing scheme and a few boring applications of it, but can't apply any of it to real programming tasks. This proves this book is just a fancy concotion of some egghead professor who has no idea what happens in the real world. I found many explanations to be incoherent and contradictory. The whole approach is divorced from the computing practice. This is no 21 day book, in fact, you can spend 21 months on it and still not learn a thing, because there's nothing but worthless garbage here.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "Note that his book has 657 pages, not the alleged 556 pages mentioned in the \"product details\". In my humble opinion, the best book ever written on the subject.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "No other programming book as had as a big impact as this one on me!",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I'd like to point out the fact that this book gets mixed reviews for a very good reason. It's exceedingly boring and much of the information is completely worthless as far as computer science and programming in general is concerned. I read this text when I already had some introductory data structures and algorithms knowledge, plus C++ experience. I couldn't believe some of the dumb things this book passed off as good programming, not to mention how very inconvenient Scheme is. So there you are, these authors present either simple ideas which everyone already knows, or they present interesting things in such a way that no one can understand them, and on top of that, they use a language which is inappropriate for most of the algorithms they show. If you pick up a book like \"Algorithms\" by Cormen, et.al. you'll see everything is in C-like pseudocode, and I don't know anyone who was able to successfully code things like Djikstra's algorithm in Scheme, and yet this is typical of what programmers encounter in practice. In short, this book is pedantic drivel, only of interest to hardcore computer science majors who don't really care about coding efficiency and elegance, and would rather waste time formalizing basic ideas mathematically.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "The book is like Da Vinci's Mona Lisa. It can choose who would like it and who wouldn't, not the other way around. A must read for any computer engineer.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "One of the most beautiful books I've read in a long time. Lyrical and lovely, I suspect it's best approached without an agenda.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I've never attended MIT but a friend did, he is a scheme fanatic and turned me onto emacs which I've adapted to over vim in favor of elisp, and keyboard macros a+ from what little I read of it when I had the chance; I hear it's the only \"correct\" approach to programming",
            "review_rating": "5.0 "
        }
    ]
}{
    "url": "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/?pageNumber=19",
    "reviews": [
        {
            "review_text": "Hi I bought Structure and Interpretation of Computer Programs and the Instructor's Manual hoping that the answers would be in at least one of them. No answers. I'm not enrolled in any school so don't have access via that route. Could someone please let me know where I can get them. Would greatly appreciate it. Kevin",
            "review_rating": "3.0 "
        },
        {
            "review_text": "I'm an undergrad who is currently taking an introductory class in C.S using the book as the primary textbook (actually, the only textbook). Sadly, I'm taking it with another class in computer architecture with heavy emphasis on system programming (a la C, MIPS). Like one of the reviewers having pointed out, the excessive zeal of pedantic and theoretical C.S has left the students clueless about the connection between reality and fundamental ideas presented in the book. The authors enforces a grand vision of solving problems independent of programming language. Sadly, this is not the case in practice (I have been trying to port some algorithms in the book into C, oh boy, what a frustrating experience). This vision has left me a very bad impression on Scheme (a good-for-nothing language invented by geeks to impress other geeks). Some people have said they liked the book. At the beginning of semester. I liked the book too, since programming in functional style is completely new to me (who major in C.S wouldn't delight at learning new thing). HOWEVER, the more I delved into the book while taking a computer architecture course at the same time (in which I have to design a complete 8-bit CPU from ground up, as well as doing a lot of low-level programming), the more I feel there are some fundamental issues with using Scheme (or any other functional languages for that matter) as a tool to interpret and design machines and programs. It just struck me as very odd to design a computer \"recursively\". How ironic that the book is called \"STRUCTURE and INTERPRETATION of computer programs\". I agree with some reviewers in here who bashed C in favor of Scheme. C is not a very good language, but C deserves praises. There are reasons why it has been around forever (both in academic and in industry), and at this rate, I don't see how any functional languages would emerge out of academics as replacement for C. The authors in book braggs that only Fortran has been surviving longer than Scheme, but besides surviving in the this textbook (which has been pushed down my throat by my school), I haven't seen Scheme anywhere else. This textbook reminds me of the Feynman series in Physics. A series which everyone talks about, but when it comes to reality, it's just best used as a supplementary to look up for reference and self-congratulate as being \"smart\" rather than the one used to teach and learn from.",
            "review_rating": "2.0 "
        },
        {
            "review_text": "While reading reviews of this book on my IBM\u2122 ThinkPad\u2122 running GNU/Linux, I decided that it would be a worthwhile endeavor to invest in this book. Low and behold, the night after it came in the mail, Richard Stallman himself visited me in his sleep. As he tugged down my jeans and pulled off my XXL Gentoo T-Shirt to give me his full knowledge of GNU/Linux, my NVidia\u2122 Fermi\u2122 caught fire, blinding him with woodscrews. This gave me a chance to escape, but not before I grabbed my handy IBM\u2122 ThinkPad\u2122 and copy of SICP. I'm currently typing this from my IBM\u2122 ThinkPad\u2122 sitting outside of my house, waiting for RMS to appear again so I can fill my mouth with his greasy knowledge. 11/10 would buy again.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I'm not sure who the target audience is (besides the poor MIT undergrads who are force to sift through this [junk]), but having taught (as an assistant to a professor) a lower-level computer science class (one not dealing with Scheme, thankfully) I have asked many freshmen abou their thoughts on this book and the class taught out of it. *ALL*hated it. Some PhD students, whose specialty was programming languages, tolerated it, while other PhD students also hated it. So there you have it. If you are into programming languages like Scheme, this text is for you to salivate over Hal Abelson's self fornication (how else would you call the senseless drivel he wrote?). Otherwise, stay away. Beginning CS students will come away frustrated, as virtually every conventional algorithm is NOT implementable in scheme, and those who aren't beginners and have no inherent interest in Scheme will simply find the book a waste of time.",
            "review_rating": "1.0 "
        },
        {
            "review_text": "A must read for anyone in programming. Useful for everyone who codes.",
            "review_rating": "5.0 "
        },
        {
            "review_text": "I think this is an awesome book for anyone who is studying computer science, just keep in mind that there is a certain math level required for some of the problems in the book.",
            "review_rating": "5.0 "
        }
    ]
}